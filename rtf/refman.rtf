{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\info 
{\title {\comment My Project }My Project}
{\comment Generated by doxygen 1.9.8.}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt My Project}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version \par\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\par \pard\plain 
\par \pard\plain 
\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
README\par \pard\plain 
{\tc\tcl1 \v README}
{\xe \v README}
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid network-packet-classification                                  //\par
|-.git                                                         //\par
| |-COMMIT_EDITMSG                                             //\par
| |-config                                                     //\par
| |-description                                                //\par
| |-HEAD                                                       //\par
| |-hooks                                                      //\par
| | |-applypatch-msg.sample                                    //\par
| | |-commit-msg.sample                                        //\par
| | |-fsmonitor-watchman.sample                                //\par
| | |-post-update.sample                                       //\par
| | |-pre-applypatch.sample                                    //\par
| | |-pre-commit.sample                                        //\par
| | |-pre-merge-commit.sample                                  //\par
| | |-pre-push.sample                                          //\par
| | |-pre-rebase.sample                                        //\par
| | |-pre-receive.sample                                       //\par
| | |-prepare-commit-msg.sample                                //\par
| | |-push-to-checkout.sample                                  //\par
| | |-update.sample                                            //\par
| |-index                                                      //\par
| |-info                                                       //\par
| | |-exclude                                                  //\par
| |-logs                                                       //\par
| | |-HEAD                                                     //\par
| | |-refs                                                     //\par
| | | |-heads                                                  //\par
| | | | |-main                                                 //\par
| | | |-remotes                                                //\par
| | | | |-origin                                               //\par
| | | | | |-HEAD                                               //\par
| | | | | |-main                                               //\par
| |-objects                                                    //\par
| | |-00                                                       //\par
| | | |-182ef58444923075f0ea1e111e6fc1bbbfbdaf                 //\par
| | | |-d9926fe9276a63423af1d10bd42427e48fe67f                 //\par
| | |-0a                                                       //\par
| | | |-63b9930cf5e976cc27d17cacdc325aced0b5a7                 //\par
| | |-27                                                       //\par
| | | |-44aa6d4e5616459fccb2c120c8ef0f5f15c4a2                 //\par
| | |-29                                                       //\par
| | | |-1962600935974459d3b5a0eee0bb32ffbd224c                 //\par
| | |-36                                                       //\par
| | | |-0447a588e9a12bb298884e276eb0aeab9cc0bc                 //\par
| | |-58                                                       //\par
| | | |-96ac84b7ddd3228223a33da3f17155857a287d                 //\par
| | |-5b                                                       //\par
| | | |-e02484427061a5ef65939c1ab78d729a00640f                 //\par
| | |-6e                                                       //\par
| | | |-c49fd29634ccb92fdec82f45899a921b1db62c                 //\par
| | |-71                                                       //\par
| | | |-134f9571ca333e50df5c3ebfdf337132d116fb                 //\par
| | |-7f                                                       //\par
| | | |-06b63b8cb8f96bed4a247be545fc6f13fa09a8                 //\par
| | |-80                                                       //\par
| | | |-5436ffd467bea0648302efedca799582442251                 //\par
| | |-81                                                       //\par
| | | |-e152565924bf3a6014cd28ed56354608f18e36                 //\par
| | |-9c                                                       //\par
| | | |-a8e266d28d20193326fbb045a11cbfbb5fe0ed                 //\par
| | |-9f                                                       //\par
| | | |-f18275227a4cf3f379f8365746191de45223e0                 //\par
| | |-a6                                                       //\par
| | | |-8c12371446bef51f5007bbf24573bc768e0a3c                 //\par
| | |-ae                                                       //\par
| | | |-7d9d9bf37343160ec14946f05e733c67f5ef5b                 //\par
| | |-b2                                                       //\par
| | | |-6021ebe206efc8b75ba29ce1375bee1362e179                 //\par
| | |-da                                                       //\par
| | | |-96d900ccbded00d6d961281c0a46aa884538c8                 //\par
| | |-e4                                                       //\par
| | | |-4f5494c0847ac0276fa8ba10fd607ff4fc73cf                 //\par
| | |-ea                                                       //\par
| | | |-dbfbc7f569c5f490ad1ba9d8a18222c8424f12                 //\par
| | |-f9                                                       //\par
| | | |-01376ebd30ba0717979d1935db71d92e6d6d08                 //\par
| | |-info                                                     //\par
| | |-pack                                                     //\par
| | | |-pack-488418778e12b55bd2af5e5985fc8800eae9a903.idx      //\par
| | | |-pack-488418778e12b55bd2af5e5985fc8800eae9a903.pack     //\par
| |-packed-refs                                                //\par
| |-refs                                                       //\par
| | |-heads                                                    //\par
| | | |-main                                                   //\par
| | |-remotes                                                  //\par
| | | |-origin                                                 //\par
| | | | |-HEAD                                                 //\par
| | | | |-main                                                 //\par
| | |-tags                                                     //\par
|-.gitignore                                                   //\par
|-info                                                         //\par
| |-.gitkeep                                                   //\par
| |-aInnerNode_info.txt                                        //\par
| |-aLeafNode_info.txt                                         //\par
| |-pInnerNode_info.txt                                        //\par
| |-pLeafNode_info.txt                                         //\par
| |-results.txt                                                //\par
| |-search_info.txt                                            //\par
|-IO                                                           //\par
| |-input_v1.cpp                                               //\par
| |-input_v1.hpp                                               //\par
| |-IO_TEST                                                    //\par
| | |-inputFile_test.cpp                                       //\par
| | |-inputFile_test.hpp                                       //\par
| |-output_log.cpp                                             //\par
| |-output_v1.cpp                                              //\par
| |-output_v1.hpp                                              //\par
|-LICENSE                                                      //\par
|-main.cpp                                                     //\par
|-makefile                                                     //\par
|-METHOD                                                       //\par
| |-PTtree.cpp                                                 //\par
| |-PTtree.hpp                                                 //\par
|-OBJECT                                                       //\par
| |-basis.cpp                                                  //\par
| |-basis.hpp                                                  //\par
| |-tuple_v1.hpp                                               //\par
|-PT-tree_main                                                 //\par
| |-L3.txt                                                     //\par
| |-L4.txt                                                     //\par
| |-makefile                                                   //\par
| |-ptMain.cpp                                                 //\par
| |-test                                                       //\par
| | |-.gitkeep                                                 //\par
| | |-inputPacket5D_merge_test.txt                             //\par
| | |-inputPacket5D_test.txt                                   //\par
| | |-inputRule5D_merge_test.txt                               //\par
| | |-inputRule5D_test.txt                                     //\par
|-ruleset                                                      //\par
| |-acl1_100k                                                  //\par
|-test                                                         //\par
| |-.gitkeep                                                   //\par
|-trace                                                        //\par
| |-acl1_100k_trace                                            //\par
}
 {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid network-packet-classification                                  //\par
|-.git                                                         //\par
| |-COMMIT_EDITMSG                                             //\par
| |-config                                                     //\par
| |-description                                                //\par
| |-HEAD                                                       //\par
| |-hooks                                                      //\par
| | |-applypatch-msg.sample                                    //\par
| | |-commit-msg.sample                                        //\par
| | |-fsmonitor-watchman.sample                                //\par
| | |-post-update.sample                                       //\par
| | |-pre-applypatch.sample                                    //\par
| | |-pre-commit.sample                                        //\par
| | |-pre-merge-commit.sample                                  //\par
| | |-pre-push.sample                                          //\par
| | |-pre-rebase.sample                                        //\par
| | |-pre-receive.sample                                       //\par
| | |-prepare-commit-msg.sample                                //\par
| | |-push-to-checkout.sample                                  //\par
| | |-update.sample                                            //\par
| |-index                                                      //\par
| |-info                                                       //\par
| | |-exclude                                                  //\par
| |-logs                                                       //\par
| | |-HEAD                                                     //\par
| | |-refs                                                     //\par
| | | |-heads                                                  //\par
| | | | |-main                                                 //\par
| | | |-remotes                                                //\par
| | | | |-origin                                               //\par
| | | | | |-HEAD                                               //\par
| | | | | |-main                                               //\par
| |-objects                                                    //\par
| | |-00                                                       //\par
| | | |-182ef58444923075f0ea1e111e6fc1bbbfbdaf                 //\par
| | | |-d9926fe9276a63423af1d10bd42427e48fe67f                 //\par
| | |-0a                                                       //\par
| | | |-63b9930cf5e976cc27d17cacdc325aced0b5a7                 //\par
| | |-27                                                       //\par
| | | |-44aa6d4e5616459fccb2c120c8ef0f5f15c4a2                 //\par
| | |-29                                                       //\par
| | | |-1962600935974459d3b5a0eee0bb32ffbd224c                 //\par
| | |-36                                                       //\par
| | | |-0447a588e9a12bb298884e276eb0aeab9cc0bc                 //\par
| | |-58                                                       //\par
| | | |-96ac84b7ddd3228223a33da3f17155857a287d                 //\par
| | |-5b                                                       //\par
| | | |-e02484427061a5ef65939c1ab78d729a00640f                 //\par
| | |-6e                                                       //\par
| | | |-c49fd29634ccb92fdec82f45899a921b1db62c                 //\par
| | |-71                                                       //\par
| | | |-134f9571ca333e50df5c3ebfdf337132d116fb                 //\par
| | |-7f                                                       //\par
| | | |-06b63b8cb8f96bed4a247be545fc6f13fa09a8                 //\par
| | |-80                                                       //\par
| | | |-5436ffd467bea0648302efedca799582442251                 //\par
| | |-81                                                       //\par
| | | |-e152565924bf3a6014cd28ed56354608f18e36                 //\par
| | |-9c                                                       //\par
| | | |-a8e266d28d20193326fbb045a11cbfbb5fe0ed                 //\par
| | |-9f                                                       //\par
| | | |-f18275227a4cf3f379f8365746191de45223e0                 //\par
| | |-a6                                                       //\par
| | | |-8c12371446bef51f5007bbf24573bc768e0a3c                 //\par
| | |-ae                                                       //\par
| | | |-7d9d9bf37343160ec14946f05e733c67f5ef5b                 //\par
| | |-b2                                                       //\par
| | | |-6021ebe206efc8b75ba29ce1375bee1362e179                 //\par
| | |-da                                                       //\par
| | | |-96d900ccbded00d6d961281c0a46aa884538c8                 //\par
| | |-e4                                                       //\par
| | | |-4f5494c0847ac0276fa8ba10fd607ff4fc73cf                 //\par
| | |-ea                                                       //\par
| | | |-dbfbc7f569c5f490ad1ba9d8a18222c8424f12                 //\par
| | |-f9                                                       //\par
| | | |-01376ebd30ba0717979d1935db71d92e6d6d08                 //\par
| | |-info                                                     //\par
| | |-pack                                                     //\par
| | | |-pack-488418778e12b55bd2af5e5985fc8800eae9a903.idx      //\par
| | | |-pack-488418778e12b55bd2af5e5985fc8800eae9a903.pack     //\par
| |-packed-refs                                                //\par
| |-refs                                                       //\par
| | |-heads                                                    //\par
| | | |-main                                                   //\par
| | |-remotes                                                  //\par
| | | |-origin                                                 //\par
| | | | |-HEAD                                                 //\par
| | | | |-main                                                 //\par
| | |-tags                                                     //\par
|-.gitignore                                                   //\par
|-info                                                         //\par
| |-.gitkeep                                                   //\par
| |-aInnerNode_info.txt                                        //\par
| |-aLeafNode_info.txt                                         //\par
| |-pInnerNode_info.txt                                        //\par
| |-pLeafNode_info.txt                                         //\par
| |-results.txt                                                //\par
| |-search_info.txt                                            //\par
|-IO                                                           //\par
| |-input_v1.cpp                                               //\par
| |-input_v1.hpp                                               //\par
| |-IO_TEST                                                    //\par
| | |-inputFile_test.cpp                                       //\par
| | |-inputFile_test.hpp                                       //\par
| |-output_log.cpp                                             //\par
| |-output_v1.cpp                                              //\par
| |-output_v1.hpp                                              //\par
|-LICENSE                                                      //\par
|-main.cpp                                                     //\par
|-makefile                                                     //\par
|-METHOD                                                       //\par
| |-PTtree.cpp                                                 //\par
| |-PTtree.hpp                                                 //\par
|-OBJECT                                                       //\par
| |-basis.cpp                                                  //\par
| |-basis.hpp                                                  //\par
| |-tuple_v1.hpp                                               //\par
|-PT-tree_main                                                 //\par
| |-L3.txt                                                     //\par
| |-L4.txt                                                     //\par
| |-makefile                                                   //\par
| |-ptMain.cpp                                                 //\par
| |-test                                                       //\par
| | |-.gitkeep                                                 //\par
| | |-inputPacket5D_merge_test.txt                             //\par
| | |-inputPacket5D_test.txt                                   //\par
| | |-inputRule5D_merge_test.txt                               //\par
| | |-inputRule5D_test.txt                                     //\par
|-README.md                                                    //\par
|-ruleset                                                      //\par
| |-acl1_100k                                                  //\par
|-test                                                         //\par
| |-.gitkeep                                                   //\par
|-trace                                                        //\par
| |-acl1_100k_trace                                            //\par
}
 {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid network-packet-classification          //\par
|-info                                 //\par
| |-aInnerNode_info.txt                //\par
| |-aLeafNode_info.txt                 //\par
| |-pInnerNode_info.txt                //\par
| |-pLeafNode_info.txt                 //\par
| |-results.txt                        //\par
| |-search_info.txt                    //\par
|-IO                                   //\par
| |-input_v1.cpp                       //\par
| |-input_v1.hpp                       //\par
| |-IO_TEST                            //\par
| | |-inputFile_test.cpp               //\par
| | |-inputFile_test.hpp               //\par
| |-output_log.cpp                     //\par
| |-output_v1.cpp                      //\par
| |-output_v1.hpp                      //\par
|-LICENSE                              //\par
|-main.cpp                             //\par
|-makefile                             //\par
|-METHOD                               //\par
| |-PTtree.cpp                         //\par
| |-PTtree.hpp                         //\par
|-OBJECT                               //\par
| |-basis.cpp                          //\par
| |-basis.hpp                          //\par
| |-tuple_v1.hpp                       //\par
|-PT-tree_main                         //\par
| |-L3.txt                             //\par
| |-L4.txt                             //\par
| |-makefile                           //\par
| |-ptMain.cpp                         //\par
| |-test                               //\par
| | |-inputPacket5D_merge_test.txt     //\par
| | |-inputPacket5D_test.txt           //\par
| | |-inputRule5D_merge_test.txt       //\par
| | |-inputRule5D_test.txt             //\par
|-README.md                            //\par
|-ruleset                              //\par
| |-acl1_100k                          //\par
|-test                                 //\par
|-trace                                //\par
| |-acl1_100k_trace                    //\par
}
 {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid network-packet-classification          //\par
|-info                                 //\par
| |-aInnerNode_info.txt                //\par
| |-aLeafNode_info.txt                 //\par
| |-pInnerNode_info.txt                //\par
| |-pLeafNode_info.txt                 //\par
| |-results.txt                        //\par
| |-search_info.txt                    //\par
|-IO                                   //\par
| |-input_v1.cpp                       //\par
| |-input_v1.hpp                       //\par
| |-IO_TEST                            //\par
| | |-inputFile_test.cpp               //\par
| | |-inputFile_test.hpp               //\par
| |-output_log.cpp                     //\par
| |-output_v1.cpp                      //\par
| |-output_v1.hpp                      //\par
|-LICENSE                              //\par
|-main.cpp                             //\par
|-makefile                             //\par
|-METHOD                               //\par
| |-PTtree.cpp                         //\par
| |-PTtree.hpp                         //\par
|-OBJECT                               //\par
| |-basis.cpp                          //\par
| |-basis.hpp                          //\par
| |-tuple_v1.hpp                       //\par
|-PT-tree_main                         //\par
| |-L3.txt                             //\par
| |-L4.txt                             //\par
| |-makefile                           //\par
| |-ptMain.cpp                         //\par
| |-test                               //\par
| | |-inputPacket5D_merge_test.txt     //\par
| | |-inputPacket5D_test.txt           //\par
| | |-inputRule5D_merge_test.txt       //\par
| | |-inputRule5D_test.txt             //\par
|-README.md                            //\par
|-ruleset                              //\par
| |-acl1_100k                          //\par
|-test                                 //\par
|-trace                                //\par
| |-acl1_100k_trace                    //\par
}
 {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid network-packet-classification          //\par
|-info                                 //\par
| |-aInnerNode_info.txt                //\par
| |-aLeafNode_info.txt                 //\par
| |-pInnerNode_info.txt                //\par
| |-pLeafNode_info.txt                 //\par
| |-results.txt                        //\par
| |-search_info.txt                    //\par
|-IO                                   //\par
| |-input_v1.cpp                       //\par
| |-input_v1.hpp                       //\par
| |-IO_TEST                            //\par
| | |-inputFile_test.cpp               //\par
| | |-inputFile_test.hpp               //\par
| |-output_log.cpp                     //\par
| |-output_v1.cpp                      //\par
| |-output_v1.hpp                      //\par
|-LICENSE                              //\par
|-main.cpp                             //\par
|-makefile                             //\par
|-METHOD                               //\par
| |-PTtree.cpp                         //\par
| |-PTtree.hpp                         //\par
|-OBJECT                               //\par
| |-basis.cpp                          //\par
| |-basis.hpp                          //\par
| |-tuple_v1.hpp                       //\par
|-PT-tree_main                         //\par
| |-L3.txt                             //\par
| |-L4.txt                             //\par
| |-makefile                           //\par
| |-ptMain.cpp                         //\par
| |-test                               //\par
| | |-inputPacket5D_merge_test.txt     //\par
| | |-inputPacket5D_test.txt           //\par
| | |-inputRule5D_merge_test.txt       //\par
| | |-inputRule5D_test.txt             //\par
|-README.md                            //\par
|-ruleset                              //\par
| |-acl1_100k                          //\par
|-test                                 //\par
|-trace                                //\par
| |-acl1_100k_trace                    //\par
}
 {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid network-packet-classification             //\par
\'E2\'94\'9C\'E2\'94\'80 info                                   //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 aInnerNode_info.txt                 //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 aLeafNode_info.txt                  //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 pInnerNode_info.txt                 //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 pLeafNode_info.txt                  //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 results.txt                         //\par
\'E2\'94\'82  \'E2\'94\'94\'E2\'94\'80 search_info.txt                     //\par
\'E2\'94\'9C\'E2\'94\'80 IO                                     //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 input_v1.cpp                        //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 input_v1.hpp                        //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 IO_TEST                             //\par
\'E2\'94\'82  \'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 inputFile_test.cpp               //\par
\'E2\'94\'82  \'E2\'94\'82  \'E2\'94\'94\'E2\'94\'80 inputFile_test.hpp               //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 output_log.cpp                      //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 output_v1.cpp                       //\par
\'E2\'94\'82  \'E2\'94\'94\'E2\'94\'80 output_v1.hpp                       //\par
\'E2\'94\'9C\'E2\'94\'80 LICENSE                                //\par
\'E2\'94\'9C\'E2\'94\'80 main.cpp                               //\par
\'E2\'94\'9C\'E2\'94\'80 makefile                               //\par
\'E2\'94\'9C\'E2\'94\'80 METHOD                                 //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 PTtree.cpp                          //\par
\'E2\'94\'82  \'E2\'94\'94\'E2\'94\'80 PTtree.hpp                          //\par
\'E2\'94\'9C\'E2\'94\'80 OBJECT                                 //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 basis.cpp                           //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 basis.hpp                           //\par
\'E2\'94\'82  \'E2\'94\'94\'E2\'94\'80 tuple_v1.hpp                        //\par
\'E2\'94\'9C\'E2\'94\'80 PT-tree_main                           //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 L3.txt                              //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 L4.txt                              //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 makefile                            //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 ptMain.cpp                          //\par
\'E2\'94\'82  \'E2\'94\'94\'E2\'94\'80 test                                //\par
\'E2\'94\'82     \'E2\'94\'9C\'E2\'94\'80 inputPacket5D_merge_test.txt     //\par
\'E2\'94\'82     \'E2\'94\'9C\'E2\'94\'80 inputPacket5D_test.txt           //\par
\'E2\'94\'82     \'E2\'94\'9C\'E2\'94\'80 inputRule5D_merge_test.txt       //\par
\'E2\'94\'82     \'E2\'94\'94\'E2\'94\'80 inputRule5D_test.txt             //\par
\'E2\'94\'9C\'E2\'94\'80 README.md                              //\par
\'E2\'94\'9C\'E2\'94\'80 ruleset                                //\par
\'E2\'94\'82  \'E2\'94\'94\'E2\'94\'80 acl1_100k                           //\par
\'E2\'94\'9C\'E2\'94\'80 test                                   //\par
\'E2\'94\'94\'E2\'94\'80 trace                                  //\par
   \'E2\'94\'94\'E2\'94\'80 acl1_100k_trace                     //\par
}
 {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid network-packet-classification     //\par
\'E2\'94\'9C\'E2\'94\'80 info                           //\par
\'E2\'94\'9C\'E2\'94\'80 IO                             //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 input_v1.cpp                //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 input_v1.hpp                //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 IO_TEST                     //\par
\'E2\'94\'82  \'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 inputFile_test.cpp       //\par
\'E2\'94\'82  \'E2\'94\'82  \'E2\'94\'94\'E2\'94\'80 inputFile_test.hpp       //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 output_log.cpp              //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 output_v1.cpp               //\par
\'E2\'94\'82  \'E2\'94\'94\'E2\'94\'80 output_v1.hpp               //\par
\'E2\'94\'9C\'E2\'94\'80 LICENSE                        //\par
\'E2\'94\'9C\'E2\'94\'80 main.cpp                       //\par
\'E2\'94\'9C\'E2\'94\'80 makefile                       //\par
\'E2\'94\'9C\'E2\'94\'80 METHOD                         //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 PTtree.cpp                  //\par
\'E2\'94\'82  \'E2\'94\'94\'E2\'94\'80 PTtree.hpp                  //\par
\'E2\'94\'9C\'E2\'94\'80 OBJECT                         //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 basis.cpp                   //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 basis.hpp                   //\par
\'E2\'94\'82  \'E2\'94\'94\'E2\'94\'80 tuple_v1.hpp                //\par
\'E2\'94\'9C\'E2\'94\'80 PT-tree_main                   //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 L3.txt                      //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 L4.txt                      //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 makefile                    //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 ptMain.cpp                  //\par
\'E2\'94\'82  \'E2\'94\'94\'E2\'94\'80 test                        //\par
\'E2\'94\'9C\'E2\'94\'80 README.md                      //\par
\'E2\'94\'9C\'E2\'94\'80 ruleset                        //\par
\'E2\'94\'82  \'E2\'94\'94\'E2\'94\'80 acl1_100k                   //\par
\'E2\'94\'9C\'E2\'94\'80 test                           //\par
\'E2\'94\'94\'E2\'94\'80 trace                          //\par
   \'E2\'94\'94\'E2\'94\'80 acl1_100k_trace             //\par
}
 {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid network-packet-classification                                      //\par
\'E2\'94\'9C\'E2\'94\'80 .git                                                            //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 config                                                       //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 description                                                  //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 HEAD                                                         //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 hooks                                                        //\par
\'E2\'94\'82  \'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 applypatch-msg.sample                                     //\par
\'E2\'94\'82  \'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 commit-msg.sample                                         //\par
\'E2\'94\'82  \'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 fsmonitor-watchman.sample                                 //\par
\'E2\'94\'82  \'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 post-update.sample                                        //\par
\'E2\'94\'82  \'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 pre-applypatch.sample                                     //\par
\'E2\'94\'82  \'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 pre-commit.sample                                         //\par
\'E2\'94\'82  \'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 pre-merge-commit.sample                                   //\par
\'E2\'94\'82  \'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 pre-push.sample                                           //\par
\'E2\'94\'82  \'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 pre-rebase.sample                                         //\par
\'E2\'94\'82  \'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 pre-receive.sample                                        //\par
\'E2\'94\'82  \'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 prepare-commit-msg.sample                                 //\par
\'E2\'94\'82  \'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 push-to-checkout.sample                                   //\par
\'E2\'94\'82  \'E2\'94\'82  \'E2\'94\'94\'E2\'94\'80 update.sample                                             //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 index                                                        //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 info                                                         //\par
\'E2\'94\'82  \'E2\'94\'82  \'E2\'94\'94\'E2\'94\'80 exclude                                                   //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 logs                                                         //\par
\'E2\'94\'82  \'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 HEAD                                                      //\par
\'E2\'94\'82  \'E2\'94\'82  \'E2\'94\'94\'E2\'94\'80 refs                                                      //\par
\'E2\'94\'82  \'E2\'94\'82     \'E2\'94\'9C\'E2\'94\'80 heads                                                  //\par
\'E2\'94\'82  \'E2\'94\'82     \'E2\'94\'82  \'E2\'94\'94\'E2\'94\'80 main                                                //\par
\'E2\'94\'82  \'E2\'94\'82     \'E2\'94\'94\'E2\'94\'80 remotes                                                //\par
\'E2\'94\'82  \'E2\'94\'82        \'E2\'94\'94\'E2\'94\'80 origin                                              //\par
\'E2\'94\'82  \'E2\'94\'82           \'E2\'94\'94\'E2\'94\'80 HEAD                                             //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 objects                                                      //\par
\'E2\'94\'82  \'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 info                                                      //\par
\'E2\'94\'82  \'E2\'94\'82  \'E2\'94\'94\'E2\'94\'80 pack                                                      //\par
\'E2\'94\'82  \'E2\'94\'82     \'E2\'94\'9C\'E2\'94\'80 pack-dcbe72207421eafd0d1d846efa080a17fb2db3c7.idx      //\par
\'E2\'94\'82  \'E2\'94\'82     \'E2\'94\'94\'E2\'94\'80 pack-dcbe72207421eafd0d1d846efa080a17fb2db3c7.pack     //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 packed-refs                                                  //\par
\'E2\'94\'82  \'E2\'94\'94\'E2\'94\'80 refs                                                         //\par
\'E2\'94\'82     \'E2\'94\'9C\'E2\'94\'80 heads                                                     //\par
\'E2\'94\'82     \'E2\'94\'82  \'E2\'94\'94\'E2\'94\'80 main                                                   //\par
\'E2\'94\'82     \'E2\'94\'9C\'E2\'94\'80 remotes                                                   //\par
\'E2\'94\'82     \'E2\'94\'82  \'E2\'94\'94\'E2\'94\'80 origin                                                 //\par
\'E2\'94\'82     \'E2\'94\'82     \'E2\'94\'94\'E2\'94\'80 HEAD                                                //\par
\'E2\'94\'82     \'E2\'94\'94\'E2\'94\'80 tags                                                      //\par
\'E2\'94\'9C\'E2\'94\'80 .gitignore                                                      //\par
\'E2\'94\'9C\'E2\'94\'80 info                                                            //\par
\'E2\'94\'82  \'E2\'94\'94\'E2\'94\'80 .gitkeep                                                     //\par
\'E2\'94\'9C\'E2\'94\'80 IO                                                              //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 input_v1.cpp                                                 //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 input_v1.hpp                                                 //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 IO_TEST                                                      //\par
\'E2\'94\'82  \'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 inputFile_test.cpp                                        //\par
\'E2\'94\'82  \'E2\'94\'82  \'E2\'94\'94\'E2\'94\'80 inputFile_test.hpp                                        //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 output_log.cpp                                               //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 output_v1.cpp                                                //\par
\'E2\'94\'82  \'E2\'94\'94\'E2\'94\'80 output_v1.hpp                                                //\par
\'E2\'94\'9C\'E2\'94\'80 LICENSE                                                         //\par
\'E2\'94\'9C\'E2\'94\'80 main.cpp                                                        //\par
\'E2\'94\'9C\'E2\'94\'80 makefile                                                        //\par
\'E2\'94\'9C\'E2\'94\'80 METHOD                                                          //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 PTtree.cpp                                                   //\par
\'E2\'94\'82  \'E2\'94\'94\'E2\'94\'80 PTtree.hpp                                                   //\par
\'E2\'94\'9C\'E2\'94\'80 OBJECT                                                          //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 basis.cpp                                                    //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 basis.hpp                                                    //\par
\'E2\'94\'82  \'E2\'94\'94\'E2\'94\'80 tuple_v1.hpp                                                 //\par
\'E2\'94\'9C\'E2\'94\'80 PT-tree_main                                                    //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 L3.txt                                                       //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 L4.txt                                                       //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 makefile                                                     //\par
\'E2\'94\'82  \'E2\'94\'9C\'E2\'94\'80 ptMain.cpp                                                   //\par
\'E2\'94\'82  \'E2\'94\'94\'E2\'94\'80 test                                                         //\par
\'E2\'94\'82     \'E2\'94\'94\'E2\'94\'80 .gitkeep                                                  //\par
\'E2\'94\'9C\'E2\'94\'80 README.md                                                       //\par
\'E2\'94\'9C\'E2\'94\'80 ruleset                                                         //\par
\'E2\'94\'82  \'E2\'94\'94\'E2\'94\'80 acl1_100k                                                    //\par
\'E2\'94\'9C\'E2\'94\'80 test                                                            //\par
\'E2\'94\'82  \'E2\'94\'94\'E2\'94\'80 .gitkeep                                                     //\par
\'E2\'94\'94\'E2\'94\'80 trace                                                           //\par
   \'E2\'94\'94\'E2\'94\'80 acl1_100k_trace                                              //\par
}
 \par
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Index\par \pard\plain 
{\tc \v Class Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the classes, structs, unions and interfaces with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b ACL_LOG} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ACL_rules} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InputFile5D} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InputFile5D_test} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b IpChild} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b IpNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b IpNode_static} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b IpTable} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b LeafNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b OutputFile5D} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Packet_5D} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b PortNode_static} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ProtoNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b PTtree} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAER \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Rule_5D} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Timer} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all files with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b main.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b IO/{\b input_v1.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b IO/{\b input_v1.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b IO/{\b output_log.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b IO/{\b output_v1.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b IO/{\b output_v1.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b IO/IO_TEST/{\b inputFile_test.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b IO/IO_TEST/{\b inputFile_test.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b METHOD/{\b PTtree.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b METHOD/{\b PTtree.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b OBJECT/{\b basis.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b OBJECT/{\b basis.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b OBJECT/{\b tuple_v1.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b PT-tree_main/{\b ptMain.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Documentation{\tc \v Class Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ACL_LOG Struct Reference\par \pard\plain 
{\tc\tcl2 \v ACL_LOG}
{\xe \v ACL_LOG}
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
\par
{
{\f2 #include <PTtree.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ACL_LOG} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b rules}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b tables}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b innerNodes}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b leafNodes}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< void * > {\b ipNodeList}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b LeafNode} * > {\b pLeafNodeList}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< void * > {\b portNodeList}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b LeafNode} * > {\b aLeafNodeList}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 55} of file {\b PTtree.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ACL_LOG\:ACL_LOG}
{\xe \v ACL_LOG\:ACL_LOG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ACL_LOG::ACL_LOG (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 64} of file {\b PTtree.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v aLeafNodeList\:ACL_LOG}
{\xe \v ACL_LOG\:aLeafNodeList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<{\b LeafNode}*> ACL_LOG::aLeafNodeList}}
\par
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 63} of file {\b PTtree.hpp}.}\par
}
{\xe \v innerNodes\:ACL_LOG}
{\xe \v ACL_LOG\:innerNodes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ACL_LOG::innerNodes}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 58} of file {\b PTtree.hpp}.}\par
}
{\xe \v ipNodeList\:ACL_LOG}
{\xe \v ACL_LOG\:ipNodeList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<void*> ACL_LOG::ipNodeList}}
\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 60} of file {\b PTtree.hpp}.}\par
}
{\xe \v leafNodes\:ACL_LOG}
{\xe \v ACL_LOG\:leafNodes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ACL_LOG::leafNodes}}
\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b PTtree.hpp}.}\par
}
{\xe \v pLeafNodeList\:ACL_LOG}
{\xe \v ACL_LOG\:pLeafNodeList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<{\b LeafNode}*> ACL_LOG::pLeafNodeList}}
\par
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 61} of file {\b PTtree.hpp}.}\par
}
{\xe \v portNodeList\:ACL_LOG}
{\xe \v ACL_LOG\:portNodeList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<void*> ACL_LOG::portNodeList}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 62} of file {\b PTtree.hpp}.}\par
}
{\xe \v rules\:ACL_LOG}
{\xe \v ACL_LOG\:rules}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ACL_LOG::rules}}
\par
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 56} of file {\b PTtree.hpp}.}\par
}
{\xe \v tables\:ACL_LOG}
{\xe \v ACL_LOG\:tables}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ACL_LOG::tables}}
\par
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 57} of file {\b PTtree.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
METHOD/{\b PTtree.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ACL_rules Struct Reference\par \pard\plain 
{\tc\tcl2 \v ACL_rules}
{\xe \v ACL_rules}
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
\par
{
{\f2 #include <basis.hpp>}}\par
Collaboration diagram for ACL_rules:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_a_c_l__rules__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ACL_rules} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b size}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b capacity}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Rule_5D} * {\b list}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 116} of file {\b basis.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ACL_rules\:ACL_rules}
{\xe \v ACL_rules\:ACL_rules}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ACL_rules::ACL_rules (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 120} of file {\b basis.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v capacity\:ACL_rules}
{\xe \v ACL_rules\:capacity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ACL_rules::capacity}}
\par
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 118} of file {\b basis.hpp}.}\par
}
{\xe \v list\:ACL_rules}
{\xe \v ACL_rules\:list}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Rule_5D}* ACL_rules::list}}
\par
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 119} of file {\b basis.hpp}.}\par
}
{\xe \v size\:ACL_rules}
{\xe \v ACL_rules\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ACL_rules::size}}
\par
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 117} of file {\b basis.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
OBJECT/{\b basis.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InputFile5D Class Reference\par \pard\plain 
{\tc\tcl2 \v InputFile5D}
{\xe \v InputFile5D}
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
\par
{
{\f2 #include <input_v1.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b inputRule5D} (std::vector< {\b Rule_5D} > &, const char *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b inputPacket5D} (std::vector< {\b Packet_5D} > &, const char *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b rule_5D_ip_merge} (std::vector< {\b Rule_5D} > &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b packet_5D_ip_merge} (std::vector< {\b Packet_5D} > &)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 11} of file {\b input_v1.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v inputPacket5D\:InputFile5D}
{\xe \v InputFile5D\:inputPacket5D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool InputFile5D::inputPacket5D (std::vector< {\b Packet_5D} > &  {\i packetV}, const char *  {\i file_name})}}
\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 58} of file {\b input_v1.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_input_file5_d_a7a799faa8926c26b62583a6c14eddf8e_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v inputRule5D\:InputFile5D}
{\xe \v InputFile5D\:inputRule5D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool InputFile5D::inputRule5D (std::vector< {\b Rule_5D} > &  {\i ruleV}, const char *  {\i file_name})}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8} of file {\b input_v1.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_input_file5_d_a36f47a5d78295a001ab065705b68f641_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v packet_5D_ip_merge\:InputFile5D}
{\xe \v InputFile5D\:packet_5D_ip_merge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InputFile5D::packet_5D_ip_merge (std::vector< {\b Packet_5D} > &  {\i packetV})}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 92} of file {\b input_v1.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_input_file5_d_a04d9d25b339e6ea566d222c8e0f0f637_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v rule_5D_ip_merge\:InputFile5D}
{\xe \v InputFile5D\:rule_5D_ip_merge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InputFile5D::rule_5D_ip_merge (std::vector< {\b Rule_5D} > &  {\i ruleV})}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 87} of file {\b input_v1.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_input_file5_d_a241ae1c709ebb9cec6534c0fcef51340_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IO/{\b input_v1.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IO/{\b input_v1.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InputFile5D_test Class Reference\par \pard\plain 
{\tc\tcl2 \v InputFile5D_test}
{\xe \v InputFile5D_test}
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
\par
{
{\f2 #include <inputFile_test.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b inputRule5D_test} (std::vector< {\b Rule_5D} > &, const char *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b inputPacket5D_test} (std::vector< {\b Packet_5D} > &, const char *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b inputRule5D_merge_test} (std::vector< {\b Rule_5D} > &, const char *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b inputPacket5D_merge_test} (std::vector< {\b Packet_5D} > &, const char *)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 10} of file {\b inputFile_test.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v inputPacket5D_merge_test\:InputFile5D_test}
{\xe \v InputFile5D_test\:inputPacket5D_merge_test}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool InputFile5D_test::inputPacket5D_merge_test (std::vector< {\b Packet_5D} > &  {\i packetV}, const char *  {\i file_name})}}
\par
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 119} of file {\b inputFile_test.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_input_file5_d__test_acf868ef63685c900790d5cf09885951f_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v inputPacket5D_test\:InputFile5D_test}
{\xe \v InputFile5D_test\:inputPacket5D_test}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool InputFile5D_test::inputPacket5D_test (std::vector< {\b Packet_5D} > &  {\i packetV}, const char *  {\i file_name})}}
\par
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 47} of file {\b inputFile_test.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_input_file5_d__test_aa5f7f9920a3a95425ce5e89e04f7981f_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v inputRule5D_merge_test\:InputFile5D_test}
{\xe \v InputFile5D_test\:inputRule5D_merge_test}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool InputFile5D_test::inputRule5D_merge_test (std::vector< {\b Rule_5D} > &  {\i ruleV}, const char *  {\i file_name})}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 82} of file {\b inputFile_test.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_input_file5_d__test_ab469a30ce9f8202565eadb86f3c0894c_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v inputRule5D_test\:InputFile5D_test}
{\xe \v InputFile5D_test\:inputRule5D_test}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool InputFile5D_test::inputRule5D_test (std::vector< {\b Rule_5D} > &  {\i ruleV}, const char *  {\i file_name})}}
\par
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 9} of file {\b inputFile_test.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_input_file5_d__test_acb3d8e9ae09868dc49609feb60c91c1f_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IO/IO_TEST/{\b inputFile_test.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IO/IO_TEST/{\b inputFile_test.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
IpChild Struct Reference\par \pard\plain 
{\tc\tcl2 \v IpChild}
{\xe \v IpChild}
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
\par
{
{\f2 #include <PTtree.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IpChild} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b pointer}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pri}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 24} of file {\b PTtree.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v IpChild\:IpChild}
{\xe \v IpChild\:IpChild}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IpChild::IpChild (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b PTtree.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v pointer\:IpChild}
{\xe \v IpChild\:pointer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* IpChild::pointer}}
\par
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b PTtree.hpp}.}\par
}
{\xe \v pri\:IpChild}
{\xe \v IpChild\:pri}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int IpChild::pri}}
\par
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b PTtree.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
METHOD/{\b PTtree.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
IpNode Struct Reference\par \pard\plain 
{\tc\tcl2 \v IpNode}
{\xe \v IpNode}
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
\par
{
{\f2 #include <PTtree.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IpNode} (uint8_t _field, bool _cType, uint16_t _layer, uint32_t _id)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b id}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b layer}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b field}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b childType}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b IpTable} > {\b tableList}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 14} of file {\b PTtree.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v IpNode\:IpNode}
{\xe \v IpNode\:IpNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IpNode::IpNode (uint8_t  {\i _field}, bool  {\i _cType}, uint16_t  {\i _layer}, uint32_t  {\i _id}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 20} of file {\b PTtree.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v childType\:IpNode}
{\xe \v IpNode\:childType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool IpNode::childType}}
\par
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b PTtree.hpp}.}\par
}
{\xe \v field\:IpNode}
{\xe \v IpNode\:field}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t IpNode::field}}
\par
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17} of file {\b PTtree.hpp}.}\par
}
{\xe \v id\:IpNode}
{\xe \v IpNode\:id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t IpNode::id}}
\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b PTtree.hpp}.}\par
}
{\xe \v layer\:IpNode}
{\xe \v IpNode\:layer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t IpNode::layer}}
\par
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16} of file {\b PTtree.hpp}.}\par
}
{\xe \v tableList\:IpNode}
{\xe \v IpNode\:tableList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<{\b IpTable}> IpNode::tableList}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 19} of file {\b PTtree.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
METHOD/{\b PTtree.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
IpNode_static Struct Reference\par \pard\plain 
{\tc\tcl2 \v IpNode_static}
{\xe \v IpNode_static}
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
\par
{
{\f2 #include <PTtree.hpp>}}\par
Collaboration diagram for IpNode_static:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_ip_node__static__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IpNode_static} (uint8_t _field, bool _cType, uint16_t _layer, uint32_t _id)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b id}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b layer}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b field}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b childType}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IpChild} {\b child} [257]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 29} of file {\b PTtree.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v IpNode_static\:IpNode_static}
{\xe \v IpNode_static\:IpNode_static}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IpNode_static::IpNode_static (uint8_t  {\i _field}, bool  {\i _cType}, uint16_t  {\i _layer}, uint32_t  {\i _id}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b PTtree.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v child\:IpNode_static}
{\xe \v IpNode_static\:child}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IpChild} IpNode_static::child[257]}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b PTtree.hpp}.}\par
}
{\xe \v childType\:IpNode_static}
{\xe \v IpNode_static\:childType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool IpNode_static::childType}}
\par
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b PTtree.hpp}.}\par
}
{\xe \v field\:IpNode_static}
{\xe \v IpNode_static\:field}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t IpNode_static::field}}
\par
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b PTtree.hpp}.}\par
}
{\xe \v id\:IpNode_static}
{\xe \v IpNode_static\:id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t IpNode_static::id}}
\par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 30} of file {\b PTtree.hpp}.}\par
}
{\xe \v layer\:IpNode_static}
{\xe \v IpNode_static\:layer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t IpNode_static::layer}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b PTtree.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
METHOD/{\b PTtree.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
IpTable Struct Reference\par \pard\plain 
{\tc\tcl2 \v IpTable}
{\xe \v IpTable}
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
\par
{
{\f2 #include <PTtree.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IpTable} (uint32_t n)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b pri}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b mask}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< short > {\b table}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::pair< uint32_t, void * > > {\b child}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 6} of file {\b PTtree.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v IpTable\:IpTable}
{\xe \v IpTable\:IpTable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IpTable::IpTable (uint32_t  {\i n}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11} of file {\b PTtree.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v child\:IpTable}
{\xe \v IpTable\:child}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<std::pair<uint32_t, void*> > IpTable::child}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 10} of file {\b PTtree.hpp}.}\par
}
{\xe \v mask\:IpTable}
{\xe \v IpTable\:mask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t IpTable::mask}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8} of file {\b PTtree.hpp}.}\par
}
{\xe \v pri\:IpTable}
{\xe \v IpTable\:pri}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t IpTable::pri}}
\par
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 7} of file {\b PTtree.hpp}.}\par
}
{\xe \v table\:IpTable}
{\xe \v IpTable\:table}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<short> IpTable::table}}
\par
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 9} of file {\b PTtree.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
METHOD/{\b PTtree.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
LeafNode Struct Reference\par \pard\plain 
{\tc\tcl2 \v LeafNode}
{\xe \v LeafNode}
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
\par
{
{\f2 #include <PTtree.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b Rule_5D} > {\b Rule_5D}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 38} of file {\b PTtree.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v Rule_5D\:LeafNode}
{\xe \v LeafNode\:Rule_5D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<{\b Rule_5D}> LeafNode::Rule_5D}}
\par
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b PTtree.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
METHOD/{\b PTtree.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
OutputFile5D Class Reference\par \pard\plain 
{\tc\tcl2 \v OutputFile5D}
{\xe \v OutputFile5D}
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
\par
{
{\f2 #include <output_v1.hpp>}}\par
Collaboration diagram for OutputFile5D:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_output_file5_d__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b getMemSize} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b memReset} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gen_trace} (std::vector< {\b Packet_5D} > &packets, std::vector< {\b Rule_5D} > &rules, unsigned int size)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b memSize} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Timer} {\b timer}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 9} of file {\b output_v1.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v gen_trace\:OutputFile5D}
{\xe \v OutputFile5D\:gen_trace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void OutputFile5D::gen_trace (std::vector< {\b Packet_5D} > &  {\i packets}, std::vector< {\b Rule_5D} > &  {\i rules}, unsigned int  {\i size})}}
\par
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11} of file {\b output_v1.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_output_file5_d_a84f3261d670d0b80701dbb04ac77ce85_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v getMemSize\:OutputFile5D}
{\xe \v OutputFile5D\:getMemSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t OutputFile5D::getMemSize ()}}
\par
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8} of file {\b output_v1.cpp}.}\par
}
{\xe \v memReset\:OutputFile5D}
{\xe \v OutputFile5D\:memReset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void OutputFile5D::memReset ()}}
\par
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 9} of file {\b output_v1.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v memSize\:OutputFile5D}
{\xe \v OutputFile5D\:memSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t OutputFile5D::memSize = 0}}
\par
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11} of file {\b output_v1.hpp}.}\par
}
{\xe \v timer\:OutputFile5D}
{\xe \v OutputFile5D\:timer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Timer} OutputFile5D::timer}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b output_v1.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IO/{\b output_v1.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IO/{\b output_v1.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Packet_5D Class Reference\par \pard\plain 
{\tc\tcl2 \v Packet_5D}
{\xe \v Packet_5D}
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
\par
{
{\f2 #include <basis.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ip_merge} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b portS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b portD}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
union \{\par

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ uint8_t {\b ipS} [4]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ uint32_t {\b ipS32}\par
}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\}; \par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b protocol}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
union \{\par

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ uint8_t {\b ipD} [4]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ uint32_t {\b ipD32}\par
}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\}; \par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 41} of file {\b basis.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v ip_merge\:Packet_5D}
{\xe \v Packet_5D\:ip_merge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Packet_5D::ip_merge ()}}
\par
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17} of file {\b basis.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
union  \{ ... \}  {\b Packet_5D}}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
union  \{ ... \}  {\b Packet_5D}}}
\par
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ipD\:Packet_5D}
{\xe \v Packet_5D\:ipD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Packet_5D::ipD[4]}}
\par
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b basis.hpp}.}\par
}
{\xe \v ipD32\:Packet_5D}
{\xe \v Packet_5D\:ipD32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t Packet_5D::ipD32}}
\par
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 52} of file {\b basis.hpp}.}\par
}
{\xe \v ipS\:Packet_5D}
{\xe \v Packet_5D\:ipS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Packet_5D::ipS[4]}}
\par
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b basis.hpp}.}\par
}
{\xe \v ipS32\:Packet_5D}
{\xe \v Packet_5D\:ipS32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t Packet_5D::ipS32}}
\par
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 47} of file {\b basis.hpp}.}\par
}
{\xe \v portD\:Packet_5D}
{\xe \v Packet_5D\:portD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t Packet_5D::portD}}
\par
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 44} of file {\b basis.hpp}.}\par
}
{\xe \v portS\:Packet_5D}
{\xe \v Packet_5D\:portS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t Packet_5D::portS}}
\par
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 43} of file {\b basis.hpp}.}\par
}
{\xe \v protocol\:Packet_5D}
{\xe \v Packet_5D\:protocol}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Packet_5D::protocol}}
\par
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 49} of file {\b basis.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
OBJECT/{\b basis.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
OBJECT/{\b basis.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
PortNode_static Struct Reference\par \pard\plain 
{\tc\tcl2 \v PortNode_static}
{\xe \v PortNode_static}
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
\par
{
{\f2 #include <PTtree.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PortNode_static} (uint32_t _id)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b id}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
short {\b table} [32769]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::pair< uint32_t, {\b LeafNode} * > > {\b child}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 41} of file {\b PTtree.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v PortNode_static\:PortNode_static}
{\xe \v PortNode_static\:PortNode_static}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
PortNode_static::PortNode_static (uint32_t  {\i _id}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 45} of file {\b PTtree.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v child\:PortNode_static}
{\xe \v PortNode_static\:child}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<std::pair<uint32_t, {\b LeafNode}*> > PortNode_static::child}}
\par
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 44} of file {\b PTtree.hpp}.}\par
}
{\xe \v id\:PortNode_static}
{\xe \v PortNode_static\:id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t PortNode_static::id}}
\par
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 42} of file {\b PTtree.hpp}.}\par
}
{\xe \v table\:PortNode_static}
{\xe \v PortNode_static\:table}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
short PortNode_static::table[32769]}}
\par
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 43} of file {\b PTtree.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
METHOD/{\b PTtree.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ProtoNode Struct Reference\par \pard\plain 
{\tc\tcl2 \v ProtoNode}
{\xe \v ProtoNode}
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
\par
{
{\f2 #include <PTtree.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ProtoNode} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< short > {\b table}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::pair< uint32_t, void * > > {\b child}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 49} of file {\b PTtree.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ProtoNode\:ProtoNode}
{\xe \v ProtoNode\:ProtoNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ProtoNode::ProtoNode (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 52} of file {\b PTtree.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v child\:ProtoNode}
{\xe \v ProtoNode\:child}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<std::pair<uint32_t, void*> > ProtoNode::child}}
\par
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b PTtree.hpp}.}\par
}
{\xe \v table\:ProtoNode}
{\xe \v ProtoNode\:table}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<short> ProtoNode::table}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b PTtree.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
METHOD/{\b PTtree.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
PTtree Class Reference\par \pard\plain 
{\tc\tcl2 \v PTtree}
{\xe \v PTtree}
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
\par
{
{\f2 #include <PTtree.hpp>}}\par
Collaboration diagram for PTtree:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_p_ttree__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PTtree} (std::vector< uint8_t > &v, int _portField)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PTtree} (std::vector< uint8_t > &v, int _portField, int _portStep)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~PTtree} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b freeStaticNode} ({\b IpNode_static} *node)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b freeNode} ({\b IpNode} *node)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b insert} ({\b Rule_5D} &r)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b insert_up} ({\b Rule_5D} &r)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b remove} ({\b Rule_5D} &r)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b search} ({\b Packet_5D} &p)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b search_with_log} ({\b Packet_5D} &p, {\b ACL_LOG} &log)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b update} (std::vector< {\b Rule_5D} > &rules, int num, struct timespec &t1, struct timespec &t2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_node_info} (int level, int rules)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b get_ipNode_mem} ({\b IpNode} *node)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b get_leafNode_mem} ({\b LeafNode} *node)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b get_static_mem} ({\b IpNode_static} *node)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b get_mem} ({\b IpNode} *node)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b mem} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b analyse_ruleset} (std::vector< {\b Rule_5D} > &v)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b pTree}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ProtoNode} * {\b aTree}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b totalNodes}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< void * > {\b ipNodeList}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< void * > {\b portNodeList}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b LeafNode} * > {\b pLeafNodeList}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b LeafNode} * > {\b aLeafNodeList}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 67} of file {\b PTtree.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v PTtree\:PTtree}
{\xe \v PTtree\:PTtree}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
PTtree::PTtree (std::vector< uint8_t > &  {\i v}, int  {\i _portField})}}
\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5} of file {\b PTtree.cpp}.}\par
}
{\xe \v PTtree\:PTtree}
{\xe \v PTtree\:PTtree}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
PTtree::PTtree (std::vector< uint8_t > &  {\i v}, int  {\i _portField}, int  {\i _portStep})}}
\par
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~PTtree\:PTtree}
{\xe \v PTtree\:~PTtree}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
PTtree::~PTtree ()}}
\par
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b PTtree.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_p_ttree_ae0564f1566489b55424440a13210bd86_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v analyse_ruleset\:PTtree}
{\xe \v PTtree\:analyse_ruleset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PTtree::analyse_ruleset (std::vector< {\b Rule_5D} > &  {\i v})}}
\par
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1775} of file {\b PTtree.cpp}.}\par
}
{\xe \v freeNode\:PTtree}
{\xe \v PTtree\:freeNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PTtree::freeNode ({\b IpNode} *  {\i node})}}
\par
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 49} of file {\b PTtree.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_p_ttree_a241b62afe6eaafb5ec60e50d054bc3c1_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_p_ttree_a241b62afe6eaafb5ec60e50d054bc3c1_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v freeStaticNode\:PTtree}
{\xe \v PTtree\:freeStaticNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PTtree::freeStaticNode ({\b IpNode_static} *  {\i node})}}
\par
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b PTtree.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_p_ttree_a2926ab85ae379d5e2bbbea184b4a2a54_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_p_ttree_a2926ab85ae379d5e2bbbea184b4a2a54_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v get_ipNode_mem\:PTtree}
{\xe \v PTtree\:get_ipNode_mem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t PTtree::get_ipNode_mem ({\b IpNode} *  {\i node})}}
\par
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1701} of file {\b PTtree.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_p_ttree_a1056c346a4b7e1fa5147610a38bc6934_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v get_leafNode_mem\:PTtree}
{\xe \v PTtree\:get_leafNode_mem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t PTtree::get_leafNode_mem ({\b LeafNode} *  {\i node})}}
\par
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1711} of file {\b PTtree.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_p_ttree_a3fce32d4a9c240af62d957aa33be4399_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v get_mem\:PTtree}
{\xe \v PTtree\:get_mem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t PTtree::get_mem ({\b IpNode} *  {\i node})}}
\par
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1732} of file {\b PTtree.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_p_ttree_abe949e0d60beedf4a8165987006211e5_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_p_ttree_abe949e0d60beedf4a8165987006211e5_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v get_static_mem\:PTtree}
{\xe \v PTtree\:get_static_mem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t PTtree::get_static_mem ({\b IpNode_static} *  {\i node})}}
\par
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1716} of file {\b PTtree.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_p_ttree_a40b02503f065476e8a26ea6c4ce5631c_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_p_ttree_a40b02503f065476e8a26ea6c4ce5631c_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v insert\:PTtree}
{\xe \v PTtree\:insert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PTtree::insert ({\b Rule_5D} &  {\i r})}}
\par
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 64} of file {\b PTtree.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_p_ttree_adcf32e40f4e71c240854c500b7248a83_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v insert_up\:PTtree}
{\xe \v PTtree\:insert_up}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PTtree::insert_up ({\b Rule_5D} &  {\i r})}}
\par
{\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 426} of file {\b PTtree.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_p_ttree_a94b9fcfead743f6e23bfdadca3566633_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v mem\:PTtree}
{\xe \v PTtree\:mem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t PTtree::mem ()}}
\par
{\bkmkstart AAAAAAAAFE}
{\bkmkend AAAAAAAAFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1752} of file {\b PTtree.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_p_ttree_a73d1c0128ebfb9f4711d51475d512aac_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_p_ttree_a73d1c0128ebfb9f4711d51475d512aac_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v print_node_info\:PTtree}
{\xe \v PTtree\:print_node_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PTtree::print_node_info (int  {\i level}, int  {\i rules})}}
\par
{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1568} of file {\b PTtree.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_p_ttree_a79c9de5422d02d65810a5b05dfc71f70_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v remove\:PTtree}
{\xe \v PTtree\:remove}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool PTtree::remove ({\b Rule_5D} &  {\i r})}}
\par
{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 798} of file {\b PTtree.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_p_ttree_a994cd4e3f425467bfffb8e5f468fe19f_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v search\:PTtree}
{\xe \v PTtree\:search}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int PTtree::search ({\b Packet_5D} &  {\i p})}}
\par
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1068} of file {\b PTtree.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_p_ttree_a19eac66252ad211d95c74bff21aceb59_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v search_with_log\:PTtree}
{\xe \v PTtree\:search_with_log}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int PTtree::search_with_log ({\b Packet_5D} &  {\i p}, {\b ACL_LOG} &  {\i log})}}
\par
{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1284} of file {\b PTtree.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_p_ttree_af2df1c33b41063e7c8de5a70f129384e_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v update\:PTtree}
{\xe \v PTtree\:update}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool PTtree::update (std::vector< {\b Rule_5D} > &  {\i rules}, int  {\i num}, struct timespec &  {\i t1}, struct timespec &  {\i t2})}}
\par
{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1534} of file {\b PTtree.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_p_ttree_a8c95b3d0348000cbd763dd1abd195885_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_p_ttree_a8c95b3d0348000cbd763dd1abd195885_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v aLeafNodeList\:PTtree}
{\xe \v PTtree\:aLeafNodeList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<{\b LeafNode}*> PTtree::aLeafNodeList}}
\par
{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 79} of file {\b PTtree.hpp}.}\par
}
{\xe \v aTree\:PTtree}
{\xe \v PTtree\:aTree}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ProtoNode}* PTtree::aTree}}
\par
{\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 74} of file {\b PTtree.hpp}.}\par
}
{\xe \v ipNodeList\:PTtree}
{\xe \v PTtree\:ipNodeList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<void*> PTtree::ipNodeList}}
\par
{\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 76} of file {\b PTtree.hpp}.}\par
}
{\xe \v pLeafNodeList\:PTtree}
{\xe \v PTtree\:pLeafNodeList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<{\b LeafNode}*> PTtree::pLeafNodeList}}
\par
{\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 78} of file {\b PTtree.hpp}.}\par
}
{\xe \v portNodeList\:PTtree}
{\xe \v PTtree\:portNodeList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<void*> PTtree::portNodeList}}
\par
{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 77} of file {\b PTtree.hpp}.}\par
}
{\xe \v pTree\:PTtree}
{\xe \v PTtree\:pTree}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* PTtree::pTree}}
\par
{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 73} of file {\b PTtree.hpp}.}\par
}
{\xe \v totalNodes\:PTtree}
{\xe \v PTtree\:totalNodes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int PTtree::totalNodes}}
\par
{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 75} of file {\b PTtree.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
METHOD/{\b PTtree.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
METHOD/{\b PTtree.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Rule_5D Class Reference\par \pard\plain 
{\tc\tcl2 \v Rule_5D}
{\xe \v Rule_5D}
{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
\par
{
{\f2 #include <basis.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ip_merge} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b pri} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
union \{\par

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ uint8_t {\b ipS} [4]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ uint32_t {\b ipS32}\par
}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\}; \par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
union \{\par

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ uint8_t {\b ipD} [4]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ uint32_t {\b ipD32}\par
}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\}; \par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b portS} [2]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b portD} [2]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b ipSMask}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b ipDMask}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b protocol} [2]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 21} of file {\b basis.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v ip_merge\:Rule_5D}
{\xe \v Rule_5D\:ip_merge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Rule_5D::ip_merge ()}}
\par
{\bkmkstart AAAAAAAAFS}
{\bkmkend AAAAAAAAFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 9} of file {\b basis.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
union  \{ ... \}  {\b Rule_5D}}}
\par
{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
union  \{ ... \}  {\b Rule_5D}}}
\par
{\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ipD\:Rule_5D}
{\xe \v Rule_5D\:ipD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Rule_5D::ipD[4]}}
\par
{\bkmkstart AAAAAAAAFV}
{\bkmkend AAAAAAAAFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b basis.hpp}.}\par
}
{\xe \v ipD32\:Rule_5D}
{\xe \v Rule_5D\:ipD32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t Rule_5D::ipD32}}
\par
{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 30} of file {\b basis.hpp}.}\par
}
{\xe \v ipDMask\:Rule_5D}
{\xe \v Rule_5D\:ipDMask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Rule_5D::ipDMask}}
\par
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b basis.hpp}.}\par
}
{\xe \v ipS\:Rule_5D}
{\xe \v Rule_5D\:ipS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Rule_5D::ipS[4]}}
\par
{\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b basis.hpp}.}\par
}
{\xe \v ipS32\:Rule_5D}
{\xe \v Rule_5D\:ipS32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t Rule_5D::ipS32}}
\par
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b basis.hpp}.}\par
}
{\xe \v ipSMask\:Rule_5D}
{\xe \v Rule_5D\:ipSMask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Rule_5D::ipSMask}}
\par
{\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b basis.hpp}.}\par
}
{\xe \v portD\:Rule_5D}
{\xe \v Rule_5D\:portD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t Rule_5D::portD[2]}}
\par
{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b basis.hpp}.}\par
}
{\xe \v portS\:Rule_5D}
{\xe \v Rule_5D\:portS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t Rule_5D::portS[2]}}
\par
{\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b basis.hpp}.}\par
}
{\xe \v pri\:Rule_5D}
{\xe \v Rule_5D\:pri}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int Rule_5D::pri = 0}}
\par
{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b basis.hpp}.}\par
}
{\xe \v protocol\:Rule_5D}
{\xe \v Rule_5D\:protocol}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Rule_5D::protocol[2]}}
\par
{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b basis.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
OBJECT/{\b basis.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
OBJECT/{\b basis.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Timer Class Reference\par \pard\plain 
{\tc\tcl2 \v Timer}
{\xe \v Timer}
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
\par
{
{\f2 #include <basis.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b timeReset} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b elapsed_s} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long long {\b elapsed_ns} () const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 58} of file {\b basis.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v elapsed_ns\:Timer}
{\xe \v Timer\:elapsed_ns}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long long Timer::elapsed_ns () const}}
\par
{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b basis.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_timer_ac21442a8913155b41d730059abdaabb0_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v elapsed_s\:Timer}
{\xe \v Timer\:elapsed_s}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double Timer::elapsed_s () const}}
\par
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b basis.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_timer_ab3030539a9395b4fff045a3afe05486f_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v timeReset\:Timer}
{\xe \v Timer\:timeReset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Timer::timeReset ()}}
\par
{\bkmkstart AAAAAAAAGI}
{\bkmkend AAAAAAAAGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b basis.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_timer_a32b7f4252461652a18b8e93f72a2a237_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
OBJECT/{\b basis.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
OBJECT/{\b basis.cpp}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
IO/input_v1.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v IO/input_v1.cpp}
{\xe \v IO/input_v1.cpp}
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "input_v1.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for input_v1.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "input__v1_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
input_v1.cpp\par \pard\plain 
{\tc\tcl2 \v IO/input_v1.cpp}
{\xe \v IO/input_v1.cpp}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * @title: input_v1.cpp}\par
00003 {\cf20  * @author: Jia-Chang, Chang}\par
00004 {\cf20  * @date: 2023-12-09}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #include "input_v1.hpp"}\par
00008 {\cf18 bool} InputFile5D::inputRule5D(std::vector<Rule_5D>& ruleV,\par
00009                               {\cf17 const} {\cf18 char}* file_name) \{\par
00010   FILE* fp = NULL;\par
00011   fp = fopen(file_name, {\cf22 "r"});\par
00012   {\cf19 if} (fp == NULL) \{\par
00013     fprintf(stderr, {\cf22 "error - can not open rules file\\n"});\par
00014     {\cf19 return} {\cf17 true};  {\cf20 // error}\par
00015   \}\par
00016   {\cf20 // Timer t_inputRule5D;}\par
00017   {\cf18 unsigned} {\cf18 int} ipS_fscan[5];\par
00018   {\cf18 unsigned} {\cf18 int} ipD_fscan[5];\par
00019   {\cf18 unsigned} {\cf18 int} portS_fscan[2];\par
00020   {\cf18 unsigned} {\cf18 int} portD_fscan[2];\par
00021   {\cf18 unsigned} {\cf18 int} protocol[2];\par
00022   Rule_5D r;\par
00023   {\cf19 while} (fscanf(fp,\par
00024                 {\cf22 "@%u.%u.%u.%u/%u\\t%u.%u.%u.%u/%u\\t%u : %u\\t%u : "}\par
00025                 {\cf22 "%u\\t%x/%x\\t%*x/%*x\\t\\n"},\par
00026                 &ipS_fscan[0], &ipS_fscan[1], &ipS_fscan[2], &ipS_fscan[3],\par
00027                 &ipS_fscan[4], &ipD_fscan[0], &ipD_fscan[1], &ipD_fscan[2],\par
00028                 &ipD_fscan[3], &ipD_fscan[4], &portS_fscan[0], &portS_fscan[1],\par
00029                 &portD_fscan[0], &portD_fscan[1], &protocol[0],\par
00030                 &protocol[1]) != EOF) \{\par
00031     r.pri++;\par
00032     r.protocol[0] = (uint8_t)protocol[0];\par
00033     r.protocol[1] = (uint8_t)protocol[1];\par
00034     r.ipSMask = (uint8_t)ipS_fscan[4];\par
00035     r.ipDMask = (uint8_t)ipD_fscan[4];\par
00036 \par
00037     {\cf19 for} ({\cf18 int} j = 0; j < 4; j++) \{\par
00038       r.ipS[j] = (uint8_t)ipS_fscan[j];\par
00039       r.ipD[j] = (uint8_t)ipD_fscan[j];\par
00040     \}\par
00041     r.portS[0] = (uint16_t)portS_fscan[0];\par
00042     r.portS[1] = (uint16_t)portS_fscan[1];\par
00043     r.portD[0] = (uint16_t)portD_fscan[0];\par
00044     r.portD[1] = (uint16_t)portD_fscan[1];\par
00045     ruleV.emplace_back(r);\par
00046   \}\par
00047   {\cf20 // std::cout << "Time taken: " << t_inputRule5D.elapsed_ns() << " ns"}\par
00048   {\cf20 //           << "\\n";}\par
00049   {\cf20 // std::cout << "Time taken: " << t_inputRule5D.elapsed_s() << " s"}\par
00050   {\cf20 //           << "\\n";}\par
00051   std::cout << {\cf22 "Leave inputRule5D"}\par
00052             << {\cf22 "\\n"};\par
00053   fclose(fp);\par
00054 \par
00055   {\cf19 return} {\cf17 false};  {\cf20 // argv correct}\par
00056 \};\par
00057 \par
00058 {\cf18 bool} InputFile5D::inputPacket5D(std::vector<Packet_5D>& packetV,\par
00059                                 {\cf17 const} {\cf18 char}* file_name) \{\par
00060   FILE* fp = NULL;\par
00061   fp = fopen(file_name, {\cf22 "r"});\par
00062   {\cf19 if} (fp == NULL) \{\par
00063     fprintf(stderr, {\cf22 "error - can not open trace file\\n"});\par
00064     {\cf19 return} {\cf17 true};  {\cf20 // error}\par
00065   \}\par
00066   {\cf20 // Timer t_inputPacket5D;}\par
00067   Packet_5D p;\par
00068   {\cf18 unsigned} {\cf18 int} ip_src, ip_des;\par
00069   {\cf19 while} (fscanf(fp, {\cf22 "%u\\t%u\\t%hu\\t%hu\\t%hhu\\t%*u\\t%*d\\n"}, &ip_src, &ip_des,\par
00070                 &p.portS, &p.portD, &p.protocol) != EOF) \{\par
00071     memcpy(p.ipS, &ip_src, 4);\par
00072     memcpy(p.ipD, &ip_des, 4);\par
00073 \par
00074     packetV.emplace_back(p);\par
00075   \}\par
00076   {\cf20 // std::cout << "Time taken: " << t_inputPacket5D.elapsed_ns() << " ns"}\par
00077   {\cf20 //           << "\\n";}\par
00078   {\cf20 // std::cout << "Time taken: " << t_inputPacket5D.elapsed_s() << " s"}\par
00079   {\cf20 //           << "\\n";}\par
00080   std::cout << {\cf22 "Leave inputPacket5D"}\par
00081             << {\cf22 "\\n"};\par
00082   fclose(fp);\par
00083 \par
00084   {\cf19 return} {\cf17 false};  {\cf20 // argv correct}\par
00085 \};\par
00086 \par
00087 {\cf18 void} InputFile5D::rule_5D_ip_merge(std::vector<Rule_5D>& ruleV) \{\par
00088   {\cf19 for} ({\cf17 auto}& rule : ruleV) \{\par
00089     rule.ip_merge();\par
00090   \}\par
00091 \};\par
00092 {\cf18 void} InputFile5D::packet_5D_ip_merge(std::vector<Packet_5D>& packetV) \{\par
00093   {\cf19 for} ({\cf17 auto}& packet : packetV) \{\par
00094     packet.ip_merge();\par
00095   \}\par
00096 \};\par
00097 \par
00098 {\cf20 // <Source Address> <Destination Address>   <Source Port>   <Destination}\par
00099 {\cf20 // Port>    <Protocol>  <Filter Number>}\par
00100 \par
00101 {\cf20 // The Filter Number simply records the filter used to generate the header.}\par
00102 {\cf20 // This may NOT be the best-matching (or first-matching) filter for the packet}\par
00103 {\cf20 // header.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
IO/input_v1.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v IO/input_v1.hpp}
{\xe \v IO/input_v1.hpp}
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../OBJECT/basis.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for input_v1.hpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "input__v1_8hpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "input__v1_8hpp__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InputFile5D}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
input_v1.hpp\par \pard\plain 
{\tc\tcl2 \v IO/input_v1.hpp}
{\xe \v IO/input_v1.hpp}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * @title: input_v1.hpp}\par
00003 {\cf20  * @author: Jia-Chang, Chang}\par
00004 {\cf20  * @date: 2023-12-09}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #ifndef __IO_INPUT_V1_HPP__}\par
00008 {\cf21 #define __IO_INPUT_V1_HPP__}\par
00009 \par
00010 {\cf21 #include "../OBJECT/basis.hpp"}\par
00011 {\cf17 class }InputFile5D \{\par
00012  {\cf17 public}:\par
00013   {\cf18 bool} inputRule5D(std::vector<Rule_5D>&, {\cf17 const} {\cf18 char}*);\par
00014   {\cf18 bool} inputPacket5D(std::vector<Packet_5D>&, {\cf17 const} {\cf18 char}*);\par
00015   {\cf18 void} rule_5D_ip_merge(std::vector<Rule_5D>&);\par
00016   {\cf18 void} packet_5D_ip_merge(std::vector<Packet_5D>&);\par
00017 \};\par
00018 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
IO/IO_TEST/inputFile_test.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v IO/IO_TEST/inputFile_test.cpp}
{\xe \v IO/IO_TEST/inputFile_test.cpp}
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "inputFile_test.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for inputFile_test.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "input_file__test_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
inputFile_test.cpp\par \pard\plain 
{\tc\tcl2 \v IO/IO_TEST/inputFile_test.cpp}
{\xe \v IO/IO_TEST/inputFile_test.cpp}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * @title: inputRule_test.cpp}\par
00003 {\cf20  * @author: Jia-Chang, Chang}\par
00004 {\cf20  * @date: 2023-12-09}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #include "inputFile_test.hpp"}\par
00008 \par
00009 {\cf18 bool} InputFile5D_test::inputRule5D_test(std::vector<Rule_5D>& ruleV,\par
00010                                         {\cf17 const} {\cf18 char}* file_name) \{\par
00011   std::ofstream outFile(file_name);\par
00012   {\cf19 if} (!outFile.is_open()) \{\par
00013     std::cerr << {\cf22 "Error opening output file: "} << file_name << std::endl;\par
00014     {\cf19 return} {\cf17 true};  {\cf20 // error}\par
00015   \}\par
00016   {\cf20 // Timer t_inputRule5D_test;}\par
00017   {\cf20 // Write extracted data to the output file}\par
00018   {\cf19 for} ({\cf17 const} {\cf17 auto}& rule : ruleV) \{\par
00019     outFile << {\cf22 "Priority: "} << rule.pri << {\cf22 "\\n"};\par
00020     outFile << {\cf22 "Source IP: "} << unsigned(rule.ipS[0]) << {\cf22 "."}\par
00021             << unsigned(rule.ipS[1]) << {\cf22 "."} << unsigned(rule.ipS[2]) << {\cf22 "."}\par
00022             << unsigned(rule.ipS[3]) << {\cf22 "/"} << unsigned(rule.ipSMask) << {\cf22 "\\n"};\par
00023     outFile << {\cf22 "Destination IP: "} << unsigned(rule.ipD[0]) << {\cf22 "."}\par
00024             << unsigned(rule.ipD[1]) << {\cf22 "."} << unsigned(rule.ipD[2]) << {\cf22 "."}\par
00025             << unsigned(rule.ipD[3]) << {\cf22 "/"} << unsigned(rule.ipDMask) << {\cf22 "\\n"};\par
00026     outFile << {\cf22 "Source Port: "} << unsigned(rule.portS[0]) << {\cf22 " : "}\par
00027             << unsigned(rule.portS[1]) << {\cf22 "\\n"};\par
00028     outFile << {\cf22 "Destination Port: "} << unsigned(rule.portD[0]) << {\cf22 " : "}\par
00029             << unsigned(rule.portD[1]) << {\cf22 "\\n"};\par
00030     outFile << {\cf22 "Protocol: 0x"} << std::hex\par
00031             << {\cf17 static_cast<}{\cf18 unsigned}{\cf17 >}(rule.protocol[0]) << {\cf22 " / 0x"}\par
00032             << {\cf17 static_cast<}{\cf18 unsigned}{\cf17 >}(rule.protocol[1]) << std::dec << {\cf22 "\\n"};\par
00033     outFile << {\cf22 "\\n"};\par
00034   \}\par
00035   {\cf20 //   std::cout << "Time taken: " << t_inputRule5D_test.elapsed_ns() << " ns"}\par
00036   {\cf20 //             << "\\n";}\par
00037   {\cf20 //   std::cout << "Time taken: " << t_inputRule5D_test.elapsed_s() << " s"}\par
00038   {\cf20 //             << "\\n";}\par
00039 \par
00040   std::cout << {\cf22 "Leave inputRule_test"}\par
00041             << {\cf22 "\\n"};\par
00042   outFile.close();\par
00043 \par
00044   {\cf19 return} {\cf17 false};  {\cf20 // argv correct}\par
00045 \};\par
00046 \par
00047 {\cf18 bool} InputFile5D_test::inputPacket5D_test(std::vector<Packet_5D>& packetV,\par
00048                                           {\cf17 const} {\cf18 char}* file_name) \{\par
00049   std::ofstream outFile(file_name);\par
00050   {\cf19 if} (!outFile.is_open()) \{\par
00051     std::cerr << {\cf22 "Error opening output file: "} << file_name << std::endl;\par
00052     {\cf19 return} {\cf17 true};  {\cf20 // error}\par
00053   \}\par
00054   {\cf20 // Timer t_inputPacket5D_test;}\par
00055 \par
00056   {\cf20 // Write extracted data to the output file}\par
00057   {\cf19 for} ({\cf17 const} {\cf17 auto}& packet : packetV) \{\par
00058     outFile << {\cf22 "Source IP: "} << unsigned(packet.ipS[0]) << {\cf22 "."}\par
00059             << unsigned(packet.ipS[1]) << {\cf22 "."} << unsigned(packet.ipS[2]) << {\cf22 "."}\par
00060             << unsigned(packet.ipS[3]) << {\cf22 "\\n"};\par
00061     outFile << {\cf22 "Destination IP: "} << unsigned(packet.ipD[0]) << {\cf22 "."}\par
00062             << unsigned(packet.ipD[1]) << {\cf22 "."} << unsigned(packet.ipD[2]) << {\cf22 "."}\par
00063             << unsigned(packet.ipD[3]) << {\cf22 "\\n"};\par
00064     outFile << {\cf22 "Source Port: "} << unsigned(packet.portS) << {\cf22 "\\n"};\par
00065     outFile << {\cf22 "Destination Port: "} << unsigned(packet.portD) << {\cf22 "\\n"};\par
00066     outFile << {\cf22 "Protocol: 0x"} << std::hex\par
00067             << {\cf17 static_cast<}{\cf18 unsigned}{\cf17 >}(packet.protocol) << {\cf22 "\\n"};\par
00068     outFile << {\cf22 "\\n"};\par
00069   \}\par
00070   {\cf20 //   std::cout << "Time taken: " << t_inputPacket5D_test.elapsed_ns() << " ns"}\par
00071   {\cf20 //             << "\\n";}\par
00072   {\cf20 //   std::cout << "Time taken: " << t_inputPacket5D_test.elapsed_s() << " s"}\par
00073   {\cf20 //             << "\\n";}\par
00074 \par
00075   std::cout << {\cf22 "Leave inputPacket_test"}\par
00076             << {\cf22 "\\n"};\par
00077   outFile.close();\par
00078 \par
00079   {\cf19 return} {\cf17 false};  {\cf20 // argv correct}\par
00080 \};\par
00081 \par
00082 {\cf18 bool} InputFile5D_test::inputRule5D_merge_test(std::vector<Rule_5D>& ruleV,\par
00083                                               {\cf17 const} {\cf18 char}* file_name) \{\par
00084   std::ofstream outFile(file_name);\par
00085   {\cf19 if} (!outFile.is_open()) \{\par
00086     std::cerr << {\cf22 "Error opening output file: "} << file_name << std::endl;\par
00087     {\cf19 return} {\cf17 true};  {\cf20 // error}\par
00088   \}\par
00089   {\cf20 // Timer inputRule5D_merge_test;}\par
00090   {\cf20 // Write extracted data to the output file}\par
00091   {\cf19 for} ({\cf17 const} {\cf17 auto}& rule : ruleV) \{\par
00092     outFile << {\cf22 "Priority: "} << rule.pri << {\cf22 "\\n"};\par
00093     outFile << {\cf22 "Source IP: "} << unsigned(rule.ipS32) << {\cf22 "/"}\par
00094             << unsigned(rule.ipSMask) << {\cf22 "\\n"};\par
00095     outFile << {\cf22 "Destination IP: "} << unsigned(rule.ipD32) << {\cf22 "/"}\par
00096             << unsigned(rule.ipDMask) << {\cf22 "\\n"};\par
00097     outFile << {\cf22 "Source Port: "} << unsigned(rule.portS[0]) << {\cf22 " : "}\par
00098             << unsigned(rule.portS[1]) << {\cf22 "\\n"};\par
00099     outFile << {\cf22 "Destination Port: "} << unsigned(rule.portD[0]) << {\cf22 " : "}\par
00100             << unsigned(rule.portD[1]) << {\cf22 "\\n"};\par
00101     outFile << {\cf22 "Protocol: 0x"} << std::hex\par
00102             << {\cf17 static_cast<}{\cf18 unsigned}{\cf17 >}(rule.protocol[0]) << {\cf22 " / 0x"}\par
00103             << {\cf17 static_cast<}{\cf18 unsigned}{\cf17 >}(rule.protocol[1]) << std::dec << {\cf22 "\\n"};\par
00104     outFile << {\cf22 "\\n"};\par
00105   \}\par
00106   {\cf20 //   std::cout << "Time taken: " << inputRule5D_merge_test.elapsed_ns() << "}\par
00107   {\cf20 //   ns"}\par
00108   {\cf20 //             << "\\n";}\par
00109   {\cf20 //   std::cout << "Time taken: " << inputRule5D_merge_test.elapsed_s() << " s"}\par
00110   {\cf20 //             << "\\n";}\par
00111 \par
00112   std::cout << {\cf22 "Leave inputRule5D_merge_test"}\par
00113             << {\cf22 "\\n"};\par
00114   outFile.close();\par
00115 \par
00116   {\cf19 return} {\cf17 false};  {\cf20 // argv correct}\par
00117 \};\par
00118 \par
00119 {\cf18 bool} InputFile5D_test::inputPacket5D_merge_test(std::vector<Packet_5D>& packetV,\par
00120                                                 {\cf17 const} {\cf18 char}* file_name) \{\par
00121   std::ofstream outFile(file_name);\par
00122   {\cf19 if} (!outFile.is_open()) \{\par
00123     std::cerr << {\cf22 "Error opening output file: "} << file_name << std::endl;\par
00124     {\cf19 return} {\cf17 true};  {\cf20 // error}\par
00125   \}\par
00126   {\cf20 // Timer inputPacket5D_merge_test;}\par
00127 \par
00128   {\cf20 // Write extracted data to the output file}\par
00129   {\cf19 for} ({\cf17 const} {\cf17 auto}& packet : packetV) \{\par
00130     outFile << {\cf22 "Source IP: "} << unsigned(packet.ipS32) << {\cf22 "\\n"};\par
00131     outFile << {\cf22 "Destination IP: "} << unsigned(packet.ipD32) << {\cf22 "\\n"};\par
00132     outFile << {\cf22 "Source Port: "} << unsigned(packet.portS) << {\cf22 "\\n"};\par
00133     outFile << {\cf22 "Destination Port: "} << unsigned(packet.portD) << {\cf22 "\\n"};\par
00134     outFile << {\cf22 "Protocol: 0x"} << std::hex\par
00135             << {\cf17 static_cast<}{\cf18 unsigned}{\cf17 >}(packet.protocol) << {\cf22 "\\n"};\par
00136     outFile << {\cf22 "\\n"};\par
00137   \}\par
00138   {\cf20 //   std::cout << "Time taken: " << inputPacket5D_merge_test.elapsed_ns() << "}\par
00139   {\cf20 //   ns"}\par
00140   {\cf20 //             << "\\n";}\par
00141   {\cf20 //   std::cout << "Time taken: " << inputPacket5D_merge_test.elapsed_s() << "}\par
00142   {\cf20 //   s"}\par
00143   {\cf20 //             << "\\n";}\par
00144 \par
00145   std::cout << {\cf22 "Leave inputPacket5D_merge_test"}\par
00146             << {\cf22 "\\n"};\par
00147   outFile.close();\par
00148 \par
00149   {\cf19 return} {\cf17 false};  {\cf20 // argv correct}\par
00150 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
IO/IO_TEST/inputFile_test.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v IO/IO_TEST/inputFile_test.hpp}
{\xe \v IO/IO_TEST/inputFile_test.hpp}
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../../OBJECT/basis.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for inputFile_test.hpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "input_file__test_8hpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "input_file__test_8hpp__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InputFile5D_test}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
inputFile_test.hpp\par \pard\plain 
{\tc\tcl2 \v IO/IO_TEST/inputFile_test.hpp}
{\xe \v IO/IO_TEST/inputFile_test.hpp}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * @title: inputFile_test.hpp}\par
00003 {\cf20  * @author: Jia-Chang, Chang}\par
00004 {\cf20  * @date: 2023-12-09}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #ifndef __IO_TEST_INPUTFILE_TEST_HPP__}\par
00008 {\cf21 #define __IO_TEST_INPUTFILE_TEST_HPP__}\par
00009 {\cf21 #include "../../OBJECT/basis.hpp"}\par
00010 {\cf17 class }InputFile5D_test \{\par
00011  {\cf17 public}:\par
00012   {\cf18 bool} inputRule5D_test(std::vector<Rule_5D>&, {\cf17 const} {\cf18 char}*);\par
00013   {\cf18 bool} inputPacket5D_test(std::vector<Packet_5D>&, {\cf17 const} {\cf18 char}*);\par
00014   {\cf18 bool} inputRule5D_merge_test(std::vector<Rule_5D>&, {\cf17 const} {\cf18 char}*);\par
00015   {\cf18 bool} inputPacket5D_merge_test(std::vector<Packet_5D>&, {\cf17 const} {\cf18 char}*);\par
00016 \};\par
00017 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
IO/output_log.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v IO/output_log.cpp}
{\xe \v IO/output_log.cpp}
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
output_log.cpp\par \pard\plain 
{\tc\tcl2 \v IO/output_log.cpp}
{\xe \v IO/output_log.cpp}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid }
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
IO/output_v1.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v IO/output_v1.cpp}
{\xe \v IO/output_v1.cpp}
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "output_v1.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for output_v1.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "output__v1_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
output_v1.cpp\par \pard\plain 
{\tc\tcl2 \v IO/output_v1.cpp}
{\xe \v IO/output_v1.cpp}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #}{\cf20 /*}\par
00002 {\cf20 * @title: output_v1.cpp}\par
00003 {\cf20 * @author: Jia-Chang, Chang}\par
00004 {\cf20 * @date: 2023-12-10}\par
00005 {\cf20 */}{\cf21 }\par
00006 {\cf21 #include "output_v1.hpp"}\par
00007 \par
00008 uint64_t OutputFile5D::getMemSize() \{ {\cf19 return} this->memSize; \};\par
00009 {\cf18 void} OutputFile5D::memReset() \{ this->memSize = 0; \};\par
00010 \par
00011 {\cf18 void} OutputFile5D::gen_trace(std::vector<Packet_5D>& packets,\par
00012                              std::vector<Rule_5D>& rules, {\cf18 unsigned} {\cf18 int} size) \{\par
00013   std::random_device seed;\par
00014   std::mt19937 rd(seed());\par
00015   std::uniform_int_distribution<> dis(0, rules.size() - 1);\par
00016 \par
00017   {\cf18 unsigned} {\cf18 int} protocol[] = \{1, 2, 3, 4, 5, 6, 7, 8, 17, 47, 50, 51, 88, 89\};\par
00018 \par
00019   {\cf18 unsigned} {\cf18 int} sip, dip, index;\par
00020   {\cf18 unsigned} {\cf18 short} sport, dport;\par
00021   {\cf18 unsigned} {\cf18 int} smask, dmask;\par
00022   {\cf19 for} ({\cf18 unsigned} {\cf18 int} i = 0; i < size; i++) \{\par
00023     Packet_5D p;\par
00024     index = dis(rd);\par
00025     memcpy(&sip, rules[index].ipS, {\cf17 sizeof}({\cf18 int}));\par
00026     memcpy(&dip, rules[index].ipD, {\cf17 sizeof}({\cf18 int}));\par
00027     smask = rules[index].ipSMask;\par
00028     dmask = rules[index].ipDMask;\par
00029     {\cf19 if} (smask == 0)\par
00030       sip = rd();\par
00031     {\cf19 else} {\cf19 if} (smask < 32) \{\par
00032       {\cf18 int} mbit = 32 - smask;\par
00033       {\cf18 unsigned} {\cf18 int} temp = sip >> mbit;\par
00034       temp = (temp << mbit) + (rd() % (1 << mbit));\par
00035       {\cf19 if} (temp >> mbit == sip >> mbit)\par
00036         sip = temp;\par
00037       {\cf19 else}\par
00038         fprintf(stderr, {\cf22 "Error - gen sip error.\\n"});\par
00039     \}\par
00040     memcpy(p.ipS, &sip, {\cf17 sizeof}({\cf18 int}));\par
00041     {\cf19 if} (dmask == 0)\par
00042       dip = rd();\par
00043     {\cf19 else} {\cf19 if} (dmask < 32) \{\par
00044       {\cf18 int} mbit = 32 - dmask;\par
00045       {\cf18 unsigned} {\cf18 int} temp = dip >> mbit;\par
00046       temp = (temp << mbit) + (rd() % (1 << mbit));\par
00047       {\cf19 if} (temp >> mbit == dip >> mbit)\par
00048         dip = temp;\par
00049       {\cf19 else}\par
00050         fprintf(stderr, {\cf22 "Error - gen dip error.\\n"});\par
00051     \}\par
00052     memcpy(p.ipD, &dip, {\cf17 sizeof}({\cf18 int}));\par
00053     {\cf18 int} Pwidth = rules[index].portS[1] - rules[index].portS[0];\par
00054     {\cf19 if} (Pwidth == 0)\par
00055       sport = rules[index].portS[0];\par
00056     {\cf19 else} \{\par
00057       sport = rd() % Pwidth + rules[index].portS[0];\par
00058       {\cf19 if} (sport < rules[index].portS[0] || sport > rules[index].portS[1])\par
00059         fprintf(stderr, {\cf22 "Error - gen sport error.\\n"});\par
00060     \}\par
00061     p.portS = sport;\par
00062     Pwidth = rules[index].portD[1] - rules[index].portD[0];\par
00063     {\cf19 if} (Pwidth == 0)\par
00064       dport = rules[index].portD[0];\par
00065     {\cf19 else} \{\par
00066       dport = rd() % Pwidth + rules[index].portD[0];\par
00067       {\cf19 if} (dport < rules[index].portD[0] || dport > rules[index].portD[1])\par
00068         fprintf(stderr, {\cf22 "Error - gen dport error.\\n"});\par
00069     \}\par
00070     p.portD = dport;\par
00071     {\cf19 if} (rules[index].protocol[0] == 0)\par
00072       p.protocol = protocol[rd() % ({\cf17 sizeof}(protocol) / 4)];\par
00073     {\cf19 else}\par
00074       p.protocol = rules[index].protocol[1];\par
00075     packets.emplace_back(p);\par
00076   \}\par
00077 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
IO/output_v1.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v IO/output_v1.hpp}
{\xe \v IO/output_v1.hpp}
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../OBJECT/basis.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for output_v1.hpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "output__v1_8hpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "output__v1_8hpp__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b OutputFile5D}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
output_v1.hpp\par \pard\plain 
{\tc\tcl2 \v IO/output_v1.hpp}
{\xe \v IO/output_v1.hpp}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * @title: output_v1.hpp}\par
00003 {\cf20  * @author: Jia-Chang, Chang}\par
00004 {\cf20  * @date: 2023-12-10}\par
00005 {\cf20  */}\par
00006 {\cf21 #ifndef __IO_OUTPUT_V1_HPP__}\par
00007 {\cf21 #define __IO_OUTPUT_V1_HPP__}\par
00008 {\cf21 #include "../OBJECT/basis.hpp"}\par
00009 {\cf17 class }OutputFile5D \{\par
00010  {\cf17 public}:\par
00011   uint64_t memSize = 0;\par
00012   Timer timer;\par
00013 \par
00014   uint64_t getMemSize();\par
00015   {\cf18 void} memReset();\par
00016 \par
00017   {\cf18 void} gen_trace(std::vector<Packet_5D>& packets, std::vector<Rule_5D>& rules,\par
00018                  {\cf18 unsigned} {\cf18 int} size);\par
00019 \};\par
00020 \par
00021 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
main.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v main.cpp}
{\xe \v main.cpp}
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "./IO/IO_TEST/inputFile_test.hpp"}\par
{\f2 #include "./IO/input_v1.hpp"}\par
{\f2 #include "./IO/output_v1.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for main.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "main_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} (int argc, char *argv[])\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:main.cpp}
{\xe \v main.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main (int  {\i argc}, char *  {\i argv}[])}}
\par
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13} of file {\b main.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "main_8cpp_a0ddf1224851353fc92bfbff6f499fa97_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
main.cpp\par \pard\plain 
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * @title: main.cpp}\par
00003 {\cf20  * @author: Jia-Chang, Chang}\par
00004 {\cf20  * @date: 2023-12-08}\par
00005 {\cf20  */}\par
00006 {\cf21 #include "./IO/IO_TEST/inputFile_test.hpp"}\par
00007 {\cf21 #include "./IO/input_v1.hpp"}\par
00008 {\cf21 #include "./IO/output_v1.hpp"}\par
00009 {\cf17 using }std::cerr;\par
00010 {\cf17 using }std::cin;\par
00011 {\cf17 using }std::cout;\par
00012 {\cf17 using }std::vector;\par
00013 {\cf18 int} main({\cf18 int} argc, {\cf18 char} *argv[]) \{\par
00014   vector<Rule_5D> rule5V;\par
00015   vector<Packet_5D> packet5V;\par
00016   InputFile5D InputFile_5D;\par
00017   InputFile5D_test InputFile5D_test;\par
00018   OutputFile5D OutputFile_5D;\par
00019 \par
00020   {\cf17 static} {\cf17 struct }option long_options[] = \{\par
00021       \{{\cf22 "ruleset"}, required_argument, NULL, {\cf23 'r'}\},\par
00022       \{{\cf22 "trace"}, required_argument, NULL, {\cf23 'p'}\},\par
00023       \{{\cf22 "unit_test"}, no_argument, NULL, {\cf23 't'}\},\par
00024       \{{\cf22 "merge"}, no_argument, NULL, {\cf23 'm'}\},\par
00025       \{{\cf22 "merge_test"}, no_argument, NULL, {\cf23 'n'}\},\par
00026       \{{\cf22 "help"}, no_argument, NULL, {\cf23 'h'}\},\par
00027       \{0, 0, 0, 0\}  {\cf20 // End of options marker}\par
00028   \};\par
00029   {\cf18 int} option;\par
00030   {\cf19 while} ((option = getopt_long(argc, argv, {\cf22 "r:p:t::m::n::h::"}, long_options,\par
00031                                {\cf17 nullptr})) != -1) \{\par
00032     {\cf19 switch} (option) \{\par
00033       {\cf19 case} {\cf23 'r'}:\par
00034         cout << {\cf22 "Read ruleset:  "} << optarg << {\cf22 "\\n"};\par
00035         OutputFile_5D.timer.timeReset();\par
00036         {\cf19 if} (InputFile_5D.inputRule5D(rule5V, optarg)) \{\par
00037           cout << {\cf22 "Read ruleset ERROR!!"}\par
00038                << {\cf22 "\\n"};\par
00039           {\cf19 return} -1;\par
00040         \}\par
00041         cout << {\cf22 "Read ruleset time(ns): "} << OutputFile_5D.timer.elapsed_ns()\par
00042              << {\cf22 "\\n"};\par
00043         cout << {\cf22 "Read ruleset time(s): "} << OutputFile_5D.timer.elapsed_s()\par
00044              << {\cf22 "\\n"};\par
00045         {\cf19 break};\par
00046       {\cf19 case} {\cf23 'p'}:\par
00047         cout << {\cf22 "Rread trace: "} << optarg << {\cf22 "\\n"};\par
00048         OutputFile_5D.timer.timeReset();\par
00049         {\cf19 if} (InputFile_5D.inputPacket5D(packet5V, optarg)) \{\par
00050           cout << {\cf22 "Read trace ERROR!!"}\par
00051                << {\cf22 "\\n"};\par
00052           {\cf19 return} -1;\par
00053         \}\par
00054         cout << {\cf22 "Read trace time(ns): "} << OutputFile_5D.timer.elapsed_ns()\par
00055              << {\cf22 "\\n"};\par
00056         cout << {\cf22 "Read trace time(s): "} << OutputFile_5D.timer.elapsed_s()\par
00057              << {\cf22 "\\n"};\par
00058         {\cf19 break};\par
00059       {\cf19 case} {\cf23 't'}:\par
00060         {\cf20 // Don't need argument}\par
00061         OutputFile_5D.timer.timeReset();\par
00062         {\cf19 if} (InputFile5D_test.inputRule5D_test(rule5V,\par
00063                                               {\cf22 "./test/inputRule5D_test.txt"})) \{\par
00064           cout << {\cf22 "Input Rule test ERROR!!"}\par
00065                << {\cf22 "\\n"};\par
00066           {\cf19 return} -1;\par
00067         \}\par
00068         cout << {\cf22 "Input rule test time(ns): "} << OutputFile_5D.timer.elapsed_ns()\par
00069              << {\cf22 "\\n"};\par
00070         cout << {\cf22 "Input rule test time(s): "} << OutputFile_5D.timer.elapsed_s()\par
00071              << {\cf22 "\\n"};\par
00072 \par
00073         OutputFile_5D.timer.timeReset();\par
00074         {\cf19 if} (InputFile5D_test.inputPacket5D_test(\par
00075                 packet5V, {\cf22 "./test/inputPacket5D_test.txt"})) \{\par
00076           cout << {\cf22 "Input Packet test ERROR!!"}\par
00077                << {\cf22 "\\n"};\par
00078           {\cf19 return} -1;\par
00079         \}\par
00080         cout << {\cf22 "Input packet test time(ns): "}\par
00081              << OutputFile_5D.timer.elapsed_ns() << {\cf22 "\\n"};\par
00082         cout << {\cf22 "Input packet test time(s): "} << OutputFile_5D.timer.elapsed_s()\par
00083              << {\cf22 "\\n"};\par
00084         {\cf19 break};\par
00085       {\cf19 case} {\cf23 'm'}:\par
00086         {\cf20 // Don't need argument}\par
00087         OutputFile_5D.timer.timeReset();\par
00088         InputFile_5D.rule_5D_ip_merge(rule5V);\par
00089         InputFile_5D.packet_5D_ip_merge(packet5V);\par
00090         cout << {\cf22 "Merge ip time(ns): "} << OutputFile_5D.timer.elapsed_ns()\par
00091              << {\cf22 "\\n"};\par
00092         cout << {\cf22 "Merge ip time(s): "} << OutputFile_5D.timer.elapsed_s() << {\cf22 "\\n"};\par
00093         {\cf19 break};\par
00094       {\cf19 case} {\cf23 'n'}:\par
00095         {\cf20 // Don't need argument}\par
00096         OutputFile_5D.timer.timeReset();\par
00097         {\cf19 if} (InputFile5D_test.inputRule5D_merge_test(\par
00098                 rule5V, {\cf22 "./test/inputRule5D_merge_test.txt"})) \{\par
00099           cout << {\cf22 "Input Rule merge test ERROR!!"}\par
00100                << {\cf22 "\\n"};\par
00101           {\cf19 return} -1;\par
00102         \}\par
00103         cout << {\cf22 "Input rule merge test time(ns): "}\par
00104              << OutputFile_5D.timer.elapsed_ns() << {\cf22 "\\n"};\par
00105         cout << {\cf22 "Input rule merge test time(s): "}\par
00106              << OutputFile_5D.timer.elapsed_s() << {\cf22 "\\n"};\par
00107 \par
00108         OutputFile_5D.timer.timeReset();\par
00109         {\cf19 if} (InputFile5D_test.inputPacket5D_merge_test(\par
00110                 packet5V, {\cf22 "./test/inputPacket5D_merge_test.txt"})) \{\par
00111           cout << {\cf22 "Input Packet merge test ERROR!!"}\par
00112                << {\cf22 "\\n"};\par
00113           {\cf19 return} -1;\par
00114         \}\par
00115         cout << {\cf22 "Input packet merge test time(ns): "}\par
00116              << OutputFile_5D.timer.elapsed_ns() << {\cf22 "\\n"};\par
00117         cout << {\cf22 "Input packet merge test time(s): "}\par
00118              << OutputFile_5D.timer.elapsed_s() << {\cf22 "\\n"};\par
00119         {\cf19 break};\par
00120       {\cf19 case} {\cf23 'h'}:\par
00121         {\cf20 // Don't need argument}\par
00122         cout << {\cf22 "****************************"}\par
00123              << {\cf22 "\\n"};\par
00124 \par
00125         cout << {\cf22 "****************************"}\par
00126              << {\cf22 "\\n"};\par
00127 \par
00128         {\cf19 break};\par
00129       {\cf19 case} {\cf23 '?'}:\par
00130         {\cf20 // Invalid option or missing argument}\par
00131         cerr << {\cf22 "Usage: "} << argv[0] << {\cf22 " -h   to get help"}\par
00132              << {\cf22 "\\n"};\par
00133 \par
00134         {\cf19 return} 1;\par
00135       {\cf19 default}:\par
00136         {\cf19 break};\par
00137     \}\par
00138   \}\par
00139 \par
00140   {\cf19 return} 0;\par
00141 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
METHOD/PTtree.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v METHOD/PTtree.cpp}
{\xe \v METHOD/PTtree.cpp}
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "PTtree.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for PTtree.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "_p_ttree_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b check_correct} ({\b Rule_5D} &a, {\b Packet_5D} &b)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b simple_search} (std::vector< {\b Rule_5D} > &rules, {\b Packet_5D} &b)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setmaskHash} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b maskHash} [33][4]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v check_correct\:PTtree.cpp}
{\xe \v PTtree.cpp\:check_correct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int check_correct ({\b Rule_5D} &  {\i a}, {\b Packet_5D} &  {\i b})}}
\par
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1855} of file {\b PTtree.cpp}.}\par
}
{\xe \v setmaskHash\:PTtree.cpp}
{\xe \v PTtree.cpp\:setmaskHash}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setmaskHash ()}}
\par
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1890} of file {\b PTtree.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "_p_ttree_8cpp_abbad462dd1fbeaad29449e0e78e118ce_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v simple_search\:PTtree.cpp}
{\xe \v PTtree.cpp\:simple_search}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int simple_search (std::vector< {\b Rule_5D} > &  {\i rules}, {\b Packet_5D} &  {\i b})}}
\par
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1871} of file {\b PTtree.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v maskHash\:PTtree.cpp}
{\xe \v PTtree.cpp\:maskHash}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t maskHash[33][4]}}
\par
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3} of file {\b PTtree.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
PTtree.cpp\par \pard\plain 
{\tc\tcl2 \v METHOD/PTtree.cpp}
{\xe \v METHOD/PTtree.cpp}
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "PTtree.hpp"}\par
00002 \par
00003 uint8_t maskHash[33][4];\par
00004 \par
00005 PTtree::PTtree(std::vector<uint8_t>& v, {\cf18 int} _portField)\par
00006     : layerFields(v),\par
00007       portField(_portField),\par
00008       pTree(NULL),\par
00009       aTree(NULL),\par
00010       totalNodes(0) \{\}\par
00011 \par
00012 PTtree::~PTtree() \{\par
00013   {\cf19 if} (pTree != NULL) \{\par
00014     {\cf19 switch} (layerFields.size()) \{\par
00015       {\cf19 case} 3: \{\par
00016         freeStaticNode((IpNode_static*)pTree);\par
00017         {\cf19 break};\par
00018       \}\par
00019       {\cf19 default}:\par
00020         freeNode((IpNode*)pTree);\par
00021         {\cf19 break};\par
00022     \}\par
00023   \}\par
00024   {\cf19 if} (aTree != NULL) \{\par
00025     {\cf19 for} ({\cf17 auto}&& c : aTree->child) \{\par
00026       PortNode_static* pnode = (PortNode_static*)c.second;\par
00027       {\cf19 for} ({\cf17 auto}&& leaf : pnode->child) \{\par
00028         {\cf17 delete} (leaf.second);\par
00029       \}\par
00030       {\cf17 delete} (pnode);\par
00031     \}\par
00032     {\cf17 delete} (aTree);\par
00033   \}\par
00034 \}\par
00035 \par
00036 {\cf18 void} PTtree::freeStaticNode(IpNode_static* node) \{\par
00037   {\cf19 if} (node->childType) \{\par
00038     {\cf19 for} ({\cf17 auto}&& c : node->child) \{\par
00039       {\cf19 if} (c.pointer != NULL) {\cf17 delete} ((LeafNode*)c.pointer);\par
00040     \}\par
00041   \} {\cf19 else} \{\par
00042     {\cf19 for} ({\cf17 auto}&& c : node->child) \{\par
00043       {\cf19 if} (c.pointer != NULL) freeStaticNode((IpNode_static*)c.pointer);\par
00044     \}\par
00045   \}\par
00046   {\cf17 delete} (node);\par
00047 \}\par
00048 \par
00049 {\cf18 void} PTtree::freeNode(IpNode* node) \{\par
00050   {\cf19 if} (node->childType) \{\par
00051     {\cf19 for} ({\cf17 auto}&& t : node->tableList) \{\par
00052       {\cf19 for} ({\cf18 int} i = 0; i < t.child.size(); ++i)\par
00053         {\cf17 delete} ((LeafNode*)(t.child[i].second));\par
00054     \}\par
00055   \} {\cf19 else} \{\par
00056     {\cf19 for} ({\cf17 auto}&& t : node->tableList) \{\par
00057       {\cf19 for} ({\cf18 int} i = 0; i < t.child.size(); ++i)\par
00058         freeNode((IpNode*)(t.child[i].second));\par
00059     \}\par
00060   \}\par
00061   {\cf17 delete} (node);\par
00062 \}\par
00063 \par
00064 {\cf18 void} PTtree::insert(Rule_5D& r) \{\par
00065   {\cf19 if} (r.ipSMask < 4 && r.ipDMask < 4) \{  {\cf20 // inser in assit tree}\par
00066     {\cf19 if} (aTree == NULL) \{\par
00067       aTree = {\cf17 new} ProtoNode();\par
00068       ++totalNodes;\par
00069     \}\par
00070     {\cf18 int} proto = r.protocol[1];\par
00071     {\cf18 int} proto_idx = aTree->table[proto];\par
00072     {\cf18 int} lport_idx, hport_idx;\par
00073     {\cf19 if} (portField == 0) \{\par
00074       lport_idx = r.portS[0] / 2, hport_idx = r.portS[1] / 2;\par
00075     \} {\cf19 else} \{\par
00076       lport_idx = r.portD[0] / 2, hport_idx = r.portD[1] / 2;\par
00077     \}\par
00078     {\cf19 if} (proto_idx == -1) \{\par
00079       aTree->table[proto] = aTree->child.size();\par
00080       PortNode_static* pnode = {\cf17 new} PortNode_static(portNodeList.size());\par
00081       ++totalNodes;\par
00082       {\cf19 if} (lport_idx == hport_idx)\par
00083         pnode->table[lport_idx] = 0;\par
00084       {\cf19 else}\par
00085         pnode->table[32768] = 0;\par
00086       LeafNode* lnode = {\cf17 new} LeafNode();\par
00087       ++totalNodes;\par
00088       aLeafNodeList.emplace_back(lnode);\par
00089       lnode->Rule_5D.emplace_back(r);\par
00090       pnode->child.emplace_back(std::pair<uint32_t, LeafNode*>(r.pri, lnode));\par
00091       aTree->child.emplace_back(std::pair<uint32_t, void*>(r.pri, pnode));\par
00092       portNodeList.emplace_back(pnode);\par
00093     \} {\cf19 else} \{\par
00094       PortNode_static* pnode = (PortNode_static*)aTree->child[proto_idx].second;\par
00095       {\cf19 if} (r.pri < aTree->child[proto_idx].first)\par
00096         aTree->child[proto_idx].first = r.pri;\par
00097       {\cf18 int} c_id;\par
00098       {\cf19 if} (lport_idx == hport_idx)\par
00099         c_id = lport_idx;\par
00100       {\cf19 else}\par
00101         c_id = 32768;\par
00102       {\cf18 int} le_id = pnode->table[c_id];\par
00103       {\cf19 if} (le_id == -1) \{\par
00104         pnode->table[c_id] = pnode->child.size();\par
00105         LeafNode* lnode = {\cf17 new} LeafNode();\par
00106         ++totalNodes;\par
00107         aLeafNodeList.emplace_back(lnode);\par
00108         lnode->Rule_5D.emplace_back(r);\par
00109         pnode->child.emplace_back(std::pair<uint32_t, LeafNode*>(r.pri, lnode));\par
00110       \} {\cf19 else} \{\par
00111         {\cf19 if} (r.pri < pnode->child[le_id].first)\par
00112           pnode->child[le_id].first = r.pri;\par
00113         LeafNode* lnode = pnode->child[le_id].second;\par
00114         lnode->Rule_5D.emplace_back(r);\par
00115       \}\par
00116     \}\par
00117   \} {\cf19 else} \{  {\cf20 // insert in PTtree}\par
00118     {\cf19 switch} (layerFields.size()) \{\par
00119       {\cf19 case} 3: \{\par
00120         {\cf19 if} (pTree == NULL) \{\par
00121           pTree = {\cf17 new} IpNode_static(layerFields[0], 0, 0, 0);\par
00122           ipNodeList.emplace_back(pTree);\par
00123           ++totalNodes;\par
00124         \}\par
00125         IpNode_static* node = (IpNode_static*)pTree;\par
00126         {\cf18 int} layer = 0;\par
00127         {\cf18 unsigned} {\cf18 int} mask, ip;\par
00128         {\cf19 while} (layer < 2) \{\par
00129           {\cf19 switch} (node->field) \{\par
00130             {\cf19 case} 0:\par
00131               mask = maskHash[({\cf18 unsigned} int)r.ipSMask][0];\par
00132               ip = ({\cf18 unsigned} int)r.ipS[3];\par
00133               {\cf19 break};\par
00134             {\cf19 case} 1:\par
00135               mask = maskHash[({\cf18 unsigned} int)r.ipSMask][1];\par
00136               ip = ({\cf18 unsigned} int)r.ipS[2];\par
00137               {\cf19 break};\par
00138             {\cf19 case} 2:\par
00139               mask = maskHash[({\cf18 unsigned} int)r.ipSMask][2];\par
00140               ip = ({\cf18 unsigned} int)r.ipS[1];\par
00141               {\cf19 break};\par
00142             {\cf19 case} 3:\par
00143               mask = maskHash[({\cf18 unsigned} int)r.ipSMask][3];\par
00144               ip = ({\cf18 unsigned} int)r.ipS[0];\par
00145               {\cf19 break};\par
00146             {\cf19 case} 4:\par
00147               mask = maskHash[({\cf18 unsigned} int)r.ipDMask][0];\par
00148               ip = ({\cf18 unsigned} int)r.ipD[3];\par
00149               {\cf19 break};\par
00150             {\cf19 case} 5:\par
00151               mask = maskHash[({\cf18 unsigned} int)r.ipDMask][1];\par
00152               ip = ({\cf18 unsigned} int)r.ipD[2];\par
00153               {\cf19 break};\par
00154             {\cf19 case} 6:\par
00155               mask = maskHash[({\cf18 unsigned} int)r.ipDMask][2];\par
00156               ip = ({\cf18 unsigned} int)r.ipD[1];\par
00157               {\cf19 break};\par
00158             {\cf19 case} 7:\par
00159               mask = maskHash[({\cf18 unsigned} int)r.ipDMask][3];\par
00160               ip = ({\cf18 unsigned} int)r.ipD[0];\par
00161               {\cf19 break};\par
00162             {\cf19 default}:\par
00163               {\cf19 break};\par
00164           \}\par
00165           {\cf18 int} ip_idx = mask == 8 ? ip : 256;\par
00166           {\cf19 if} (node->child[ip_idx].pointer == NULL) \{\par
00167             IpNode_static* newchild = {\cf17 new} IpNode_static(\par
00168                 layerFields[layer + 1], 0, layer + 1, ipNodeList.size());\par
00169             node->child[ip_idx].pointer = newchild;\par
00170             node->child[ip_idx].pri = r.pri;\par
00171             ipNodeList.emplace_back(newchild);\par
00172             ++totalNodes;\par
00173             node = newchild;\par
00174           \} {\cf19 else} \{\par
00175             {\cf19 if} (r.pri < node->child[ip_idx].pri)\par
00176               node->child[ip_idx].pri = r.pri;\par
00177             node = (IpNode_static*)node->child[ip_idx].pointer;\par
00178           \}\par
00179           ++layer;\par
00180         \}\par
00181         {\cf20 // process leafnode}\par
00182         node->childType = 1;\par
00183         {\cf19 switch} (node->field) \{\par
00184           {\cf19 case} 0:\par
00185             mask = maskHash[({\cf18 unsigned} int)r.ipSMask][0];\par
00186             ip = ({\cf18 unsigned} int)r.ipS[3];\par
00187             {\cf19 break};\par
00188           {\cf19 case} 1:\par
00189             mask = maskHash[({\cf18 unsigned} int)r.ipSMask][1];\par
00190             ip = ({\cf18 unsigned} int)r.ipS[2];\par
00191             {\cf19 break};\par
00192           {\cf19 case} 2:\par
00193             mask = maskHash[({\cf18 unsigned} int)r.ipSMask][2];\par
00194             ip = ({\cf18 unsigned} int)r.ipS[1];\par
00195             {\cf19 break};\par
00196           {\cf19 case} 3:\par
00197             mask = maskHash[({\cf18 unsigned} int)r.ipSMask][3];\par
00198             ip = ({\cf18 unsigned} int)r.ipS[0];\par
00199             {\cf19 break};\par
00200           {\cf19 case} 4:\par
00201             mask = maskHash[({\cf18 unsigned} int)r.ipDMask][0];\par
00202             ip = ({\cf18 unsigned} int)r.ipD[3];\par
00203             {\cf19 break};\par
00204           {\cf19 case} 5:\par
00205             mask = maskHash[({\cf18 unsigned} int)r.ipDMask][1];\par
00206             ip = ({\cf18 unsigned} int)r.ipD[2];\par
00207             {\cf19 break};\par
00208           {\cf19 case} 6:\par
00209             mask = maskHash[({\cf18 unsigned} int)r.ipDMask][2];\par
00210             ip = ({\cf18 unsigned} int)r.ipD[1];\par
00211             {\cf19 break};\par
00212           {\cf19 case} 7:\par
00213             mask = maskHash[({\cf18 unsigned} int)r.ipDMask][3];\par
00214             ip = ({\cf18 unsigned} int)r.ipD[0];\par
00215             {\cf19 break};\par
00216           {\cf19 default}:\par
00217             {\cf19 break};\par
00218         \}\par
00219         {\cf18 int} ip_idx = mask == 8 ? ip : 256;\par
00220         {\cf19 if} (node->child[ip_idx].pointer == NULL) \{\par
00221           LeafNode* newchild = {\cf17 new} LeafNode();\par
00222           newchild->Rule_5D.emplace_back(r);\par
00223           node->child[ip_idx].pointer = newchild;\par
00224           node->child[ip_idx].pri = r.pri;\par
00225           pLeafNodeList.emplace_back(newchild);\par
00226           ++totalNodes;\par
00227         \} {\cf19 else} \{\par
00228           {\cf19 if} (r.pri < node->child[ip_idx].pri) node->child[ip_idx].pri = r.pri;\par
00229           LeafNode* ln = (LeafNode*)node->child[ip_idx].pointer;\par
00230           ln->Rule_5D.emplace_back(r);\par
00231         \}\par
00232         {\cf19 break};\par
00233       \}\par
00234       {\cf19 default}: \{\par
00235         {\cf19 if} (pTree == NULL) \{\par
00236           pTree = {\cf17 new} IpNode(layerFields[0], 0, 0, 0);\par
00237           ipNodeList.emplace_back(pTree);\par
00238           ++totalNodes;\par
00239         \}\par
00240         IpNode* node = (IpNode*)pTree;\par
00241         {\cf18 int} totalLayer = layerFields.size();\par
00242         {\cf18 int} layer = 0;\par
00243         {\cf18 unsigned} {\cf18 int} mask, ip;\par
00244         {\cf19 while} (layer < totalLayer - 1) \{\par
00245           {\cf19 switch} (node->field) \{\par
00246             {\cf19 case} 0:\par
00247               mask = maskHash[({\cf18 unsigned} int)r.ipSMask][0];\par
00248               ip = ({\cf18 unsigned} int)r.ipS[3] >> (8 - mask);\par
00249               {\cf19 break};\par
00250             {\cf19 case} 1:\par
00251               mask = maskHash[({\cf18 unsigned} int)r.ipSMask][1];\par
00252               ip = ({\cf18 unsigned} int)r.ipS[2] >> (8 - mask);\par
00253               {\cf19 break};\par
00254             {\cf19 case} 2:\par
00255               mask = maskHash[({\cf18 unsigned} int)r.ipSMask][2];\par
00256               ip = ({\cf18 unsigned} int)r.ipS[1] >> (8 - mask);\par
00257               {\cf19 break};\par
00258             {\cf19 case} 3:\par
00259               mask = maskHash[({\cf18 unsigned} int)r.ipSMask][3];\par
00260               ip = ({\cf18 unsigned} int)r.ipS[0] >> (8 - mask);\par
00261               {\cf19 break};\par
00262             {\cf19 case} 4:\par
00263               mask = maskHash[({\cf18 unsigned} int)r.ipDMask][0];\par
00264               ip = ({\cf18 unsigned} int)r.ipD[3] >> (8 - mask);\par
00265               {\cf19 break};\par
00266             {\cf19 case} 5:\par
00267               mask = maskHash[({\cf18 unsigned} int)r.ipDMask][1];\par
00268               ip = ({\cf18 unsigned} int)r.ipD[2] >> (8 - mask);\par
00269               {\cf19 break};\par
00270             {\cf19 case} 6:\par
00271               mask = maskHash[({\cf18 unsigned} int)r.ipDMask][2];\par
00272               ip = ({\cf18 unsigned} int)r.ipD[1] >> (8 - mask);\par
00273               {\cf19 break};\par
00274             {\cf19 case} 7:\par
00275               mask = maskHash[({\cf18 unsigned} int)r.ipDMask][3];\par
00276               ip = ({\cf18 unsigned} int)r.ipD[0] >> (8 - mask);\par
00277               {\cf19 break};\par
00278             {\cf19 default}:\par
00279               {\cf19 break};\par
00280           \}\par
00281           {\cf19 if} (node->tableList.empty()) \{  {\cf20 // do not have table, create}\par
00282             IpTable t(mask);\par
00283             IpNode* newchild = {\cf17 new} IpNode(layerFields[layer + 1], 0, layer + 1,\par
00284                                           ipNodeList.size());\par
00285             t.pri = r.pri;\par
00286             t.table[ip] = 0;\par
00287             t.child.emplace_back(std::pair<uint32_t, void*>(r.pri, newchild));\par
00288             node->tableList.emplace_back(t);\par
00289             node = newchild;\par
00290             ipNodeList.emplace_back(newchild);\par
00291             ++totalNodes;\par
00292           \} {\cf19 else} \{\par
00293             std::vector<IpTable>::iterator it = node->tableList.begin();\par
00294             {\cf19 for} (; it != node->tableList.end(); ++it) \{\par
00295               {\cf19 if} (mask == it->mask) \{  {\cf20 // have table}\par
00296                 {\cf19 if} (it->pri > r.pri) it->pri = r.pri;\par
00297                 {\cf19 if} (it->table[ip] == -1) \{  {\cf20 // creat child}\par
00298                   IpNode* newchild = {\cf17 new} IpNode(layerFields[layer + 1], 0,\par
00299                                                 layer + 1, ipNodeList.size());\par
00300                   it->table[ip] = it->child.size();\par
00301                   it->child.emplace_back(\par
00302                       std::pair<uint32_t, void*>(r.pri, newchild));\par
00303                   node = newchild;\par
00304                   ipNodeList.emplace_back(newchild);\par
00305                   ++totalNodes;\par
00306                   {\cf19 break};\par
00307                 \} {\cf19 else} \{\par
00308                   {\cf19 if} (it->child[it->table[ip]].first > r.pri)\par
00309                     it->child[it->table[ip]].first = r.pri;\par
00310                   node = (IpNode*)(it->child[it->table[ip]].second);\par
00311                   {\cf19 break};\par
00312                 \}\par
00313               \}\par
00314               {\cf19 if} (mask > it->mask) \{  {\cf20 // find the site}\par
00315                 {\cf19 break};\par
00316               \}\par
00317             \}\par
00318             {\cf19 if} (it == node->tableList.end() ||\par
00319                 mask != it->mask) \{  {\cf20 // creat table}\par
00320               IpTable t(mask);\par
00321               IpNode* newchild = {\cf17 new} IpNode(layerFields[layer + 1], 0,\par
00322                                             layer + 1, ipNodeList.size());\par
00323               t.pri = r.pri;\par
00324               t.table[ip] = t.child.size();\par
00325               t.child.emplace_back(std::pair<uint32_t, void*>(r.pri, newchild));\par
00326               node->tableList.emplace(it, t);\par
00327               node = newchild;\par
00328               ipNodeList.emplace_back(newchild);\par
00329               ++totalNodes;\par
00330             \}\par
00331           \}\par
00332           ++layer;\par
00333         \}\par
00334         {\cf20 // process leafnode}\par
00335         node->childType = 1;\par
00336         {\cf19 switch} (node->field) \{\par
00337           {\cf19 case} 0:\par
00338             mask = maskHash[({\cf18 unsigned} int)r.ipSMask][0];\par
00339             ip = ({\cf18 unsigned} int)r.ipS[3] >> (8 - mask);\par
00340             {\cf19 break};\par
00341           {\cf19 case} 1:\par
00342             mask = maskHash[({\cf18 unsigned} int)r.ipSMask][1];\par
00343             ip = ({\cf18 unsigned} int)r.ipS[2] >> (8 - mask);\par
00344             {\cf19 break};\par
00345           {\cf19 case} 2:\par
00346             mask = maskHash[({\cf18 unsigned} int)r.ipSMask][2];\par
00347             ip = ({\cf18 unsigned} int)r.ipS[1] >> (8 - mask);\par
00348             {\cf19 break};\par
00349           {\cf19 case} 3:\par
00350             mask = maskHash[({\cf18 unsigned} int)r.ipSMask][3];\par
00351             ip = ({\cf18 unsigned} int)r.ipS[0] >> (8 - mask);\par
00352             {\cf19 break};\par
00353           {\cf19 case} 4:\par
00354             mask = maskHash[({\cf18 unsigned} int)r.ipDMask][0];\par
00355             ip = ({\cf18 unsigned} int)r.ipD[3] >> (8 - mask);\par
00356             {\cf19 break};\par
00357           {\cf19 case} 5:\par
00358             mask = maskHash[({\cf18 unsigned} int)r.ipDMask][1];\par
00359             ip = ({\cf18 unsigned} int)r.ipD[2] >> (8 - mask);\par
00360             {\cf19 break};\par
00361           {\cf19 case} 6:\par
00362             mask = maskHash[({\cf18 unsigned} int)r.ipDMask][2];\par
00363             ip = ({\cf18 unsigned} int)r.ipD[1] >> (8 - mask);\par
00364             {\cf19 break};\par
00365           {\cf19 case} 7:\par
00366             mask = maskHash[({\cf18 unsigned} int)r.ipDMask][3];\par
00367             ip = ({\cf18 unsigned} int)r.ipD[0] >> (8 - mask);\par
00368             {\cf19 break};\par
00369           {\cf19 default}:\par
00370             {\cf19 break};\par
00371         \}\par
00372         {\cf19 if} (node->tableList.empty()) \{  {\cf20 // do not have table, create}\par
00373           IpTable t(mask);\par
00374           LeafNode* newchild = {\cf17 new} LeafNode();\par
00375           newchild->Rule_5D.emplace_back(r);\par
00376           t.pri = r.pri;\par
00377           t.table[ip] = 0;\par
00378           t.child.emplace_back(std::pair<uint32_t, void*>(r.pri, newchild));\par
00379           node->tableList.emplace_back(t);\par
00380           pLeafNodeList.emplace_back(newchild);\par
00381           ++totalNodes;\par
00382         \} {\cf19 else} \{\par
00383           std::vector<IpTable>::iterator it = node->tableList.begin();\par
00384           {\cf19 for} (; it != node->tableList.end(); ++it) \{\par
00385             {\cf19 if} (mask == it->mask) \{  {\cf20 // have table}\par
00386               {\cf19 if} (it->pri > r.pri) it->pri = r.pri;\par
00387               {\cf19 if} (it->table[ip] == -1) \{  {\cf20 // creat child}\par
00388                 LeafNode* newchild = {\cf17 new} LeafNode();\par
00389                 newchild->Rule_5D.emplace_back(r);\par
00390                 it->table[ip] = it->child.size();\par
00391                 it->child.emplace_back(\par
00392                     std::pair<uint32_t, void*>(r.pri, newchild));\par
00393                 pLeafNodeList.emplace_back(newchild);\par
00394                 ++totalNodes;\par
00395                 {\cf19 break};\par
00396               \} {\cf19 else} \{\par
00397                 {\cf19 if} (it->child[it->table[ip]].first > r.pri)\par
00398                   it->child[it->table[ip]].first = r.pri;\par
00399                 ((LeafNode*)(it->child[it->table[ip]].second))\par
00400                     ->Rule_5D.emplace_back(r);\par
00401                 {\cf19 break};\par
00402               \}\par
00403             \}\par
00404             {\cf19 if} (mask > it->mask) \{  {\cf20 // find the site}\par
00405               {\cf19 break};\par
00406             \}\par
00407           \}\par
00408           {\cf19 if} (it == node->tableList.end() || mask != it->mask) \{  {\cf20 // creat table}\par
00409             IpTable t(mask);\par
00410             LeafNode* newchild = {\cf17 new} LeafNode();\par
00411             newchild->Rule_5D.emplace_back(r);\par
00412             t.pri = r.pri;\par
00413             t.table[ip] = t.child.size();\par
00414             t.child.emplace_back(std::pair<uint32_t, void*>(r.pri, newchild));\par
00415             node->tableList.emplace(it, t);\par
00416             pLeafNodeList.emplace_back(newchild);\par
00417             ++totalNodes;\par
00418           \}\par
00419         \}\par
00420         {\cf19 break};\par
00421       \}\par
00422     \}\par
00423   \}\par
00424 \}\par
00425 \par
00426 {\cf18 void} PTtree::insert_up(Rule_5D& r) \{\par
00427   {\cf19 if} (r.ipSMask < 4 && r.ipDMask < 4) \{  {\cf20 // inser in assit tree}\par
00428     {\cf19 if} (aTree == NULL) \{\par
00429       aTree = {\cf17 new} ProtoNode();\par
00430       ++totalNodes;\par
00431     \}\par
00432     {\cf18 int} proto = r.protocol[1];\par
00433     {\cf18 int} proto_idx = aTree->table[proto];\par
00434     {\cf18 int} lport_idx, hport_idx;\par
00435     {\cf19 if} (portField == 0) \{\par
00436       lport_idx = r.portS[0] / 2, hport_idx = r.portS[1] / 2;\par
00437     \} {\cf19 else} \{\par
00438       lport_idx = r.portD[0] / 2, hport_idx = r.portD[1] / 2;\par
00439     \}\par
00440     {\cf19 if} (proto_idx == -1) \{\par
00441       aTree->table[proto] = aTree->child.size();\par
00442       PortNode_static* pnode = {\cf17 new} PortNode_static(portNodeList.size());\par
00443       ++totalNodes;\par
00444       {\cf19 if} (lport_idx == hport_idx)\par
00445         pnode->table[lport_idx] = 0;\par
00446       {\cf19 else}\par
00447         pnode->table[32768] = 0;\par
00448       LeafNode* lnode = {\cf17 new} LeafNode();\par
00449       ++totalNodes;\par
00450       aLeafNodeList.emplace_back(lnode);\par
00451       lnode->Rule_5D.emplace_back(r);\par
00452       pnode->child.emplace_back(std::pair<uint32_t, LeafNode*>(r.pri, lnode));\par
00453       aTree->child.emplace_back(std::pair<uint32_t, void*>(r.pri, pnode));\par
00454       portNodeList.emplace_back(pnode);\par
00455     \} {\cf19 else} \{\par
00456       PortNode_static* pnode = (PortNode_static*)aTree->child[proto_idx].second;\par
00457       {\cf19 if} (r.pri < aTree->child[proto_idx].first)\par
00458         aTree->child[proto_idx].first = r.pri;\par
00459       {\cf18 int} c_id;\par
00460       {\cf19 if} (lport_idx == hport_idx)\par
00461         c_id = lport_idx;\par
00462       {\cf19 else}\par
00463         c_id = 32768;\par
00464       {\cf18 int} le_id = pnode->table[c_id];\par
00465       {\cf19 if} (le_id == -1) \{\par
00466         pnode->table[c_id] = pnode->child.size();\par
00467         LeafNode* lnode = {\cf17 new} LeafNode();\par
00468         ++totalNodes;\par
00469         aLeafNodeList.emplace_back(lnode);\par
00470         lnode->Rule_5D.emplace_back(r);\par
00471         pnode->child.emplace_back(std::pair<uint32_t, LeafNode*>(r.pri, lnode));\par
00472       \} {\cf19 else} \{\par
00473         {\cf19 if} (r.pri < pnode->child[le_id].first)\par
00474           pnode->child[le_id].first = r.pri;\par
00475         LeafNode* lnode = pnode->child[le_id].second;\par
00476 \par
00477         {\cf18 int} k = 0;\par
00478         {\cf19 for} (; k < lnode->Rule_5D.size(); ++k)\par
00479           {\cf19 if} (r.pri < lnode->Rule_5D[k].pri) {\cf19 break};\par
00480         lnode->Rule_5D.emplace(lnode->Rule_5D.begin() + k, r);\par
00481       \}\par
00482     \}\par
00483   \} {\cf19 else} \{  {\cf20 // insert in PTtree}\par
00484     {\cf19 switch} (layerFields.size()) \{\par
00485       {\cf19 case} 3: \{\par
00486         {\cf19 if} (pTree == NULL) \{\par
00487           pTree = {\cf17 new} IpNode_static(layerFields[0], 0, 0, 0);\par
00488           ipNodeList.emplace_back(pTree);\par
00489           ++totalNodes;\par
00490         \}\par
00491         IpNode_static* node = (IpNode_static*)pTree;\par
00492         {\cf18 int} layer = 0;\par
00493         {\cf18 unsigned} {\cf18 int} mask, ip;\par
00494         {\cf19 while} (layer < 2) \{\par
00495           {\cf19 switch} (node->field) \{\par
00496             {\cf19 case} 0:\par
00497               mask = maskHash[({\cf18 unsigned} int)r.ipSMask][0];\par
00498               ip = ({\cf18 unsigned} int)r.ipS[3];\par
00499               {\cf19 break};\par
00500             {\cf19 case} 1:\par
00501               mask = maskHash[({\cf18 unsigned} int)r.ipSMask][1];\par
00502               ip = ({\cf18 unsigned} int)r.ipS[2];\par
00503               {\cf19 break};\par
00504             {\cf19 case} 2:\par
00505               mask = maskHash[({\cf18 unsigned} int)r.ipSMask][2];\par
00506               ip = ({\cf18 unsigned} int)r.ipS[1];\par
00507               {\cf19 break};\par
00508             {\cf19 case} 3:\par
00509               mask = maskHash[({\cf18 unsigned} int)r.ipSMask][3];\par
00510               ip = ({\cf18 unsigned} int)r.ipS[0];\par
00511               {\cf19 break};\par
00512             {\cf19 case} 4:\par
00513               mask = maskHash[({\cf18 unsigned} int)r.ipDMask][0];\par
00514               ip = ({\cf18 unsigned} int)r.ipD[3];\par
00515               {\cf19 break};\par
00516             {\cf19 case} 5:\par
00517               mask = maskHash[({\cf18 unsigned} int)r.ipDMask][1];\par
00518               ip = ({\cf18 unsigned} int)r.ipD[2];\par
00519               {\cf19 break};\par
00520             {\cf19 case} 6:\par
00521               mask = maskHash[({\cf18 unsigned} int)r.ipDMask][2];\par
00522               ip = ({\cf18 unsigned} int)r.ipD[1];\par
00523               {\cf19 break};\par
00524             {\cf19 case} 7:\par
00525               mask = maskHash[({\cf18 unsigned} int)r.ipDMask][3];\par
00526               ip = ({\cf18 unsigned} int)r.ipD[0];\par
00527               {\cf19 break};\par
00528             {\cf19 default}:\par
00529               {\cf19 break};\par
00530           \}\par
00531           {\cf18 int} ip_idx = mask == 8 ? ip : 256;\par
00532           {\cf19 if} (node->child[ip_idx].pointer == NULL) \{\par
00533             IpNode_static* newchild = {\cf17 new} IpNode_static(\par
00534                 layerFields[layer + 1], 0, layer + 1, ipNodeList.size());\par
00535             node->child[ip_idx].pointer = newchild;\par
00536             node->child[ip_idx].pri = r.pri;\par
00537             ipNodeList.emplace_back(newchild);\par
00538             ++totalNodes;\par
00539             node = newchild;\par
00540           \} {\cf19 else} \{\par
00541             {\cf19 if} (r.pri < node->child[ip_idx].pri)\par
00542               node->child[ip_idx].pri = r.pri;\par
00543             node = (IpNode_static*)node->child[ip_idx].pointer;\par
00544           \}\par
00545           ++layer;\par
00546         \}\par
00547         {\cf20 // process leafnode}\par
00548         node->childType = 1;\par
00549         {\cf19 switch} (node->field) \{\par
00550           {\cf19 case} 0:\par
00551             mask = maskHash[({\cf18 unsigned} int)r.ipSMask][0];\par
00552             ip = ({\cf18 unsigned} int)r.ipS[3];\par
00553             {\cf19 break};\par
00554           {\cf19 case} 1:\par
00555             mask = maskHash[({\cf18 unsigned} int)r.ipSMask][1];\par
00556             ip = ({\cf18 unsigned} int)r.ipS[2];\par
00557             {\cf19 break};\par
00558           {\cf19 case} 2:\par
00559             mask = maskHash[({\cf18 unsigned} int)r.ipSMask][2];\par
00560             ip = ({\cf18 unsigned} int)r.ipS[1];\par
00561             {\cf19 break};\par
00562           {\cf19 case} 3:\par
00563             mask = maskHash[({\cf18 unsigned} int)r.ipSMask][3];\par
00564             ip = ({\cf18 unsigned} int)r.ipS[0];\par
00565             {\cf19 break};\par
00566           {\cf19 case} 4:\par
00567             mask = maskHash[({\cf18 unsigned} int)r.ipDMask][0];\par
00568             ip = ({\cf18 unsigned} int)r.ipD[3];\par
00569             {\cf19 break};\par
00570           {\cf19 case} 5:\par
00571             mask = maskHash[({\cf18 unsigned} int)r.ipDMask][1];\par
00572             ip = ({\cf18 unsigned} int)r.ipD[2];\par
00573             {\cf19 break};\par
00574           {\cf19 case} 6:\par
00575             mask = maskHash[({\cf18 unsigned} int)r.ipDMask][2];\par
00576             ip = ({\cf18 unsigned} int)r.ipD[1];\par
00577             {\cf19 break};\par
00578           {\cf19 case} 7:\par
00579             mask = maskHash[({\cf18 unsigned} int)r.ipDMask][3];\par
00580             ip = ({\cf18 unsigned} int)r.ipD[0];\par
00581             {\cf19 break};\par
00582           {\cf19 default}:\par
00583             {\cf19 break};\par
00584         \}\par
00585         {\cf18 int} ip_idx = mask == 8 ? ip : 256;\par
00586         {\cf19 if} (node->child[ip_idx].pointer == NULL) \{\par
00587           LeafNode* newchild = {\cf17 new} LeafNode();\par
00588           newchild->Rule_5D.emplace_back(r);\par
00589           node->child[ip_idx].pointer = newchild;\par
00590           node->child[ip_idx].pri = r.pri;\par
00591           pLeafNodeList.emplace_back(newchild);\par
00592           ++totalNodes;\par
00593         \} {\cf19 else} \{\par
00594           {\cf19 if} (r.pri < node->child[ip_idx].pri) node->child[ip_idx].pri = r.pri;\par
00595           LeafNode* ln = (LeafNode*)node->child[ip_idx].pointer;\par
00596           {\cf18 int} k = 0;\par
00597           {\cf19 for} (; k < ln->Rule_5D.size(); ++k)\par
00598             {\cf19 if} (r.pri < ln->Rule_5D[k].pri) {\cf19 break};\par
00599           ln->Rule_5D.emplace(ln->Rule_5D.begin() + k, r);\par
00600         \}\par
00601         {\cf19 break};\par
00602       \}\par
00603       {\cf19 default}: \{\par
00604         {\cf19 if} (pTree == NULL) \{\par
00605           pTree = {\cf17 new} IpNode(layerFields[0], 0, 0, 0);\par
00606           ipNodeList.emplace_back(pTree);\par
00607           ++totalNodes;\par
00608         \}\par
00609         IpNode* node = (IpNode*)pTree;\par
00610         {\cf18 int} totalLayer = layerFields.size();\par
00611         {\cf18 int} layer = 0;\par
00612         {\cf18 unsigned} {\cf18 int} mask, ip;\par
00613         {\cf19 while} (layer < totalLayer - 1) \{\par
00614           {\cf19 switch} (node->field) \{\par
00615             {\cf19 case} 0:\par
00616               mask = maskHash[({\cf18 unsigned} int)r.ipSMask][0];\par
00617               ip = ({\cf18 unsigned} int)r.ipS[3] >> (8 - mask);\par
00618               {\cf19 break};\par
00619             {\cf19 case} 1:\par
00620               mask = maskHash[({\cf18 unsigned} int)r.ipSMask][1];\par
00621               ip = ({\cf18 unsigned} int)r.ipS[2] >> (8 - mask);\par
00622               {\cf19 break};\par
00623             {\cf19 case} 2:\par
00624               mask = maskHash[({\cf18 unsigned} int)r.ipSMask][2];\par
00625               ip = ({\cf18 unsigned} int)r.ipS[1] >> (8 - mask);\par
00626               {\cf19 break};\par
00627             {\cf19 case} 3:\par
00628               mask = maskHash[({\cf18 unsigned} int)r.ipSMask][3];\par
00629               ip = ({\cf18 unsigned} int)r.ipS[0] >> (8 - mask);\par
00630               {\cf19 break};\par
00631             {\cf19 case} 4:\par
00632               mask = maskHash[({\cf18 unsigned} int)r.ipDMask][0];\par
00633               ip = ({\cf18 unsigned} int)r.ipD[3] >> (8 - mask);\par
00634               {\cf19 break};\par
00635             {\cf19 case} 5:\par
00636               mask = maskHash[({\cf18 unsigned} int)r.ipDMask][1];\par
00637               ip = ({\cf18 unsigned} int)r.ipD[2] >> (8 - mask);\par
00638               {\cf19 break};\par
00639             {\cf19 case} 6:\par
00640               mask = maskHash[({\cf18 unsigned} int)r.ipDMask][2];\par
00641               ip = ({\cf18 unsigned} int)r.ipD[1] >> (8 - mask);\par
00642               {\cf19 break};\par
00643             {\cf19 case} 7:\par
00644               mask = maskHash[({\cf18 unsigned} int)r.ipDMask][3];\par
00645               ip = ({\cf18 unsigned} int)r.ipD[0] >> (8 - mask);\par
00646               {\cf19 break};\par
00647             {\cf19 default}:\par
00648               {\cf19 break};\par
00649           \}\par
00650           {\cf19 if} (node->tableList.empty()) \{  {\cf20 // do not have table, create}\par
00651             IpTable t(mask);\par
00652             IpNode* newchild = {\cf17 new} IpNode(layerFields[layer + 1], 0, layer + 1,\par
00653                                           ipNodeList.size());\par
00654             t.pri = r.pri;\par
00655             t.table[ip] = 0;\par
00656             t.child.emplace_back(std::pair<uint32_t, void*>(r.pri, newchild));\par
00657             node->tableList.emplace_back(t);\par
00658             node = newchild;\par
00659             ipNodeList.emplace_back(newchild);\par
00660             ++totalNodes;\par
00661           \} {\cf19 else} \{\par
00662             std::vector<IpTable>::iterator it = node->tableList.begin();\par
00663             {\cf19 for} (; it != node->tableList.end(); ++it) \{\par
00664               {\cf19 if} (mask == it->mask) \{  {\cf20 // have table}\par
00665                 {\cf19 if} (it->pri > r.pri) it->pri = r.pri;\par
00666                 {\cf19 if} (it->table[ip] == -1) \{  {\cf20 // creat child}\par
00667                   IpNode* newchild = {\cf17 new} IpNode(layerFields[layer + 1], 0,\par
00668                                                 layer + 1, ipNodeList.size());\par
00669                   it->table[ip] = it->child.size();\par
00670                   it->child.emplace_back(\par
00671                       std::pair<uint32_t, void*>(r.pri, newchild));\par
00672                   node = newchild;\par
00673                   ipNodeList.emplace_back(newchild);\par
00674                   ++totalNodes;\par
00675                   {\cf19 break};\par
00676                 \} {\cf19 else} \{\par
00677                   {\cf19 if} (it->child[it->table[ip]].first > r.pri)\par
00678                     it->child[it->table[ip]].first = r.pri;\par
00679                   node = (IpNode*)(it->child[it->table[ip]].second);\par
00680                   {\cf19 break};\par
00681                 \}\par
00682               \}\par
00683               {\cf19 if} (mask > it->mask) \{  {\cf20 // find the site}\par
00684                 {\cf19 break};\par
00685               \}\par
00686             \}\par
00687             {\cf19 if} (it == node->tableList.end() ||\par
00688                 mask != it->mask) \{  {\cf20 // creat table}\par
00689               IpTable t(mask);\par
00690               IpNode* newchild = {\cf17 new} IpNode(layerFields[layer + 1], 0,\par
00691                                             layer + 1, ipNodeList.size());\par
00692               t.pri = r.pri;\par
00693               t.table[ip] = t.child.size();\par
00694               t.child.emplace_back(std::pair<uint32_t, void*>(r.pri, newchild));\par
00695               node->tableList.emplace(it, t);\par
00696               node = newchild;\par
00697               ipNodeList.emplace_back(newchild);\par
00698               ++totalNodes;\par
00699             \}\par
00700           \}\par
00701           ++layer;\par
00702         \}\par
00703         {\cf20 // process leafnode}\par
00704         node->childType = 1;\par
00705         {\cf19 switch} (node->field) \{\par
00706           {\cf19 case} 0:\par
00707             mask = maskHash[({\cf18 unsigned} int)r.ipSMask][0];\par
00708             ip = ({\cf18 unsigned} int)r.ipS[3] >> (8 - mask);\par
00709             {\cf19 break};\par
00710           {\cf19 case} 1:\par
00711             mask = maskHash[({\cf18 unsigned} int)r.ipSMask][1];\par
00712             ip = ({\cf18 unsigned} int)r.ipS[2] >> (8 - mask);\par
00713             {\cf19 break};\par
00714           {\cf19 case} 2:\par
00715             mask = maskHash[({\cf18 unsigned} int)r.ipSMask][2];\par
00716             ip = ({\cf18 unsigned} int)r.ipS[1] >> (8 - mask);\par
00717             {\cf19 break};\par
00718           {\cf19 case} 3:\par
00719             mask = maskHash[({\cf18 unsigned} int)r.ipSMask][3];\par
00720             ip = ({\cf18 unsigned} int)r.ipS[0] >> (8 - mask);\par
00721             {\cf19 break};\par
00722           {\cf19 case} 4:\par
00723             mask = maskHash[({\cf18 unsigned} int)r.ipDMask][0];\par
00724             ip = ({\cf18 unsigned} int)r.ipD[3] >> (8 - mask);\par
00725             {\cf19 break};\par
00726           {\cf19 case} 5:\par
00727             mask = maskHash[({\cf18 unsigned} int)r.ipDMask][1];\par
00728             ip = ({\cf18 unsigned} int)r.ipD[2] >> (8 - mask);\par
00729             {\cf19 break};\par
00730           {\cf19 case} 6:\par
00731             mask = maskHash[({\cf18 unsigned} int)r.ipDMask][2];\par
00732             ip = ({\cf18 unsigned} int)r.ipD[1] >> (8 - mask);\par
00733             {\cf19 break};\par
00734           {\cf19 case} 7:\par
00735             mask = maskHash[({\cf18 unsigned} int)r.ipDMask][3];\par
00736             ip = ({\cf18 unsigned} int)r.ipD[0] >> (8 - mask);\par
00737             {\cf19 break};\par
00738           {\cf19 default}:\par
00739             {\cf19 break};\par
00740         \}\par
00741         {\cf19 if} (node->tableList.empty()) \{  {\cf20 // do not have table, create}\par
00742           IpTable t(mask);\par
00743           LeafNode* newchild = {\cf17 new} LeafNode();\par
00744           newchild->Rule_5D.emplace_back(r);\par
00745           t.pri = r.pri;\par
00746           t.table[ip] = 0;\par
00747           t.child.emplace_back(std::pair<uint32_t, void*>(r.pri, newchild));\par
00748           node->tableList.emplace_back(t);\par
00749           pLeafNodeList.emplace_back(newchild);\par
00750           ++totalNodes;\par
00751         \} {\cf19 else} \{\par
00752           std::vector<IpTable>::iterator it = node->tableList.begin();\par
00753           {\cf19 for} (; it != node->tableList.end(); ++it) \{\par
00754             {\cf19 if} (mask == it->mask) \{  {\cf20 // have table}\par
00755               {\cf19 if} (it->pri > r.pri) it->pri = r.pri;\par
00756               {\cf19 if} (it->table[ip] == -1) \{  {\cf20 // creat child}\par
00757                 LeafNode* newchild = {\cf17 new} LeafNode();\par
00758                 newchild->Rule_5D.emplace_back(r);\par
00759                 it->table[ip] = it->child.size();\par
00760                 it->child.emplace_back(\par
00761                     std::pair<uint32_t, void*>(r.pri, newchild));\par
00762                 pLeafNodeList.emplace_back(newchild);\par
00763                 ++totalNodes;\par
00764                 {\cf19 break};\par
00765               \} {\cf19 else} \{\par
00766                 {\cf19 if} (it->child[it->table[ip]].first > r.pri)\par
00767                   it->child[it->table[ip]].first = r.pri;\par
00768                 LeafNode* ln = (LeafNode*)it->child[it->table[ip]].second;\par
00769                 {\cf18 int} k = 0;\par
00770                 {\cf19 for} (; k < ln->Rule_5D.size(); ++k)\par
00771                   {\cf19 if} (r.pri < ln->Rule_5D[k].pri) {\cf19 break};\par
00772                 ln->Rule_5D.emplace(ln->Rule_5D.begin() + k, r);\par
00773                 {\cf19 break};\par
00774               \}\par
00775             \}\par
00776             {\cf19 if} (mask > it->mask) \{  {\cf20 // find the site}\par
00777               {\cf19 break};\par
00778             \}\par
00779           \}\par
00780           {\cf19 if} (it == node->tableList.end() || mask != it->mask) \{  {\cf20 // creat table}\par
00781             IpTable t(mask);\par
00782             LeafNode* newchild = {\cf17 new} LeafNode();\par
00783             newchild->Rule_5D.emplace_back(r);\par
00784             t.pri = r.pri;\par
00785             t.table[ip] = t.child.size();\par
00786             t.child.emplace_back(std::pair<uint32_t, void*>(r.pri, newchild));\par
00787             node->tableList.emplace(it, t);\par
00788             pLeafNodeList.emplace_back(newchild);\par
00789             ++totalNodes;\par
00790           \}\par
00791         \}\par
00792         {\cf19 break};\par
00793       \}\par
00794     \}\par
00795   \}\par
00796 \}\par
00797 \par
00798 {\cf18 bool} PTtree::remove(Rule_5D& r) \{\par
00799   {\cf19 if} (r.ipSMask < 4 && r.ipDMask < 4) \{  {\cf20 // remove in assit tree}\par
00800     {\cf19 if} (aTree == NULL) \{\par
00801       {\cf19 return} {\cf17 false};\par
00802     \}\par
00803     {\cf18 int} proto = r.protocol[1];\par
00804     {\cf18 int} proto_idx = aTree->table[proto];\par
00805     {\cf18 int} lport_idx, hport_idx;\par
00806     {\cf19 if} (portField == 0) \{\par
00807       lport_idx = r.portS[0] / 2, hport_idx = r.portS[1] / 2;\par
00808     \} {\cf19 else} \{\par
00809       lport_idx = r.portD[0] / 2, hport_idx = r.portD[1] / 2;\par
00810     \}\par
00811     {\cf19 if} (proto_idx == -1) \{\par
00812       {\cf19 return} {\cf17 false};\par
00813     \} {\cf19 else} \{\par
00814       PortNode_static* p_node =\par
00815           (PortNode_static*)aTree->child[proto_idx].second;\par
00816       {\cf18 int} c_id;\par
00817       {\cf19 if} (lport_idx == hport_idx)\par
00818         c_id = lport_idx;\par
00819       {\cf19 else}\par
00820         c_id = 32768;\par
00821       {\cf18 int} le_id = p_node->table[c_id];\par
00822       {\cf19 if} (le_id == -1) \{\par
00823         {\cf19 return} {\cf17 false};\par
00824       \} {\cf19 else} \{\par
00825         LeafNode* lnode = p_node->child[le_id].second;\par
00826         {\cf19 for} ({\cf18 int} i = 0; i < lnode->Rule_5D.size(); ++i) \{\par
00827           {\cf19 if} (lnode->Rule_5D[i].pri == r.pri) \{\par
00828             lnode->Rule_5D.erase(lnode->Rule_5D.begin() + i);\par
00829             {\cf19 return} {\cf17 true};\par
00830           \}\par
00831         \}\par
00832         {\cf19 return} {\cf17 false};\par
00833       \}\par
00834     \}\par
00835   \} {\cf19 else} \{  {\cf20 // remove in PTtree}\par
00836     {\cf19 if} (pTree == NULL) \{\par
00837       {\cf19 return} {\cf17 false};\par
00838     \}\par
00839     {\cf19 switch} (layerFields.size()) \{\par
00840       {\cf19 case} 3: \{\par
00841         IpNode_static* node = (IpNode_static*)pTree;\par
00842         {\cf18 int} layer = 0;\par
00843         {\cf18 unsigned} {\cf18 int} mask, ip;\par
00844         {\cf19 while} (layer < 2) \{\par
00845           {\cf19 switch} (node->field) \{\par
00846             {\cf19 case} 0:\par
00847               mask = maskHash[({\cf18 unsigned} int)r.ipSMask][0];\par
00848               ip = ({\cf18 unsigned} int)r.ipS[3];\par
00849               {\cf19 break};\par
00850             {\cf19 case} 1:\par
00851               mask = maskHash[({\cf18 unsigned} int)r.ipSMask][1];\par
00852               ip = ({\cf18 unsigned} int)r.ipS[2];\par
00853               {\cf19 break};\par
00854             {\cf19 case} 2:\par
00855               mask = maskHash[({\cf18 unsigned} int)r.ipSMask][2];\par
00856               ip = ({\cf18 unsigned} int)r.ipS[1];\par
00857               {\cf19 break};\par
00858             {\cf19 case} 3:\par
00859               mask = maskHash[({\cf18 unsigned} int)r.ipSMask][3];\par
00860               ip = ({\cf18 unsigned} int)r.ipS[0];\par
00861               {\cf19 break};\par
00862             {\cf19 case} 4:\par
00863               mask = maskHash[({\cf18 unsigned} int)r.ipDMask][0];\par
00864               ip = ({\cf18 unsigned} int)r.ipD[3];\par
00865               {\cf19 break};\par
00866             {\cf19 case} 5:\par
00867               mask = maskHash[({\cf18 unsigned} int)r.ipDMask][1];\par
00868               ip = ({\cf18 unsigned} int)r.ipD[2];\par
00869               {\cf19 break};\par
00870             {\cf19 case} 6:\par
00871               mask = maskHash[({\cf18 unsigned} int)r.ipDMask][2];\par
00872               ip = ({\cf18 unsigned} int)r.ipD[1];\par
00873               {\cf19 break};\par
00874             {\cf19 case} 7:\par
00875               mask = maskHash[({\cf18 unsigned} int)r.ipDMask][3];\par
00876               ip = ({\cf18 unsigned} int)r.ipD[0];\par
00877               {\cf19 break};\par
00878             {\cf19 default}:\par
00879               {\cf19 break};\par
00880           \}\par
00881           {\cf18 int} ip_idx = mask == 8 ? ip : 256;\par
00882           {\cf19 if} (node->child[ip_idx].pointer == NULL)\par
00883             {\cf19 return} {\cf17 false};\par
00884           {\cf19 else}\par
00885             node = (IpNode_static*)node->child[ip_idx].pointer;\par
00886           ++layer;\par
00887         \}\par
00888         {\cf20 // process leafnode}\par
00889         node->childType = 1;\par
00890         {\cf19 switch} (node->field) \{\par
00891           {\cf19 case} 0:\par
00892             mask = maskHash[({\cf18 unsigned} int)r.ipSMask][0];\par
00893             ip = ({\cf18 unsigned} int)r.ipS[3];\par
00894             {\cf19 break};\par
00895           {\cf19 case} 1:\par
00896             mask = maskHash[({\cf18 unsigned} int)r.ipSMask][1];\par
00897             ip = ({\cf18 unsigned} int)r.ipS[2];\par
00898             {\cf19 break};\par
00899           {\cf19 case} 2:\par
00900             mask = maskHash[({\cf18 unsigned} int)r.ipSMask][2];\par
00901             ip = ({\cf18 unsigned} int)r.ipS[1];\par
00902             {\cf19 break};\par
00903           {\cf19 case} 3:\par
00904             mask = maskHash[({\cf18 unsigned} int)r.ipSMask][3];\par
00905             ip = ({\cf18 unsigned} int)r.ipS[0];\par
00906             {\cf19 break};\par
00907           {\cf19 case} 4:\par
00908             mask = maskHash[({\cf18 unsigned} int)r.ipDMask][0];\par
00909             ip = ({\cf18 unsigned} int)r.ipD[3];\par
00910             {\cf19 break};\par
00911           {\cf19 case} 5:\par
00912             mask = maskHash[({\cf18 unsigned} int)r.ipDMask][1];\par
00913             ip = ({\cf18 unsigned} int)r.ipD[2];\par
00914             {\cf19 break};\par
00915           {\cf19 case} 6:\par
00916             mask = maskHash[({\cf18 unsigned} int)r.ipDMask][2];\par
00917             ip = ({\cf18 unsigned} int)r.ipD[1];\par
00918             {\cf19 break};\par
00919           {\cf19 case} 7:\par
00920             mask = maskHash[({\cf18 unsigned} int)r.ipDMask][3];\par
00921             ip = ({\cf18 unsigned} int)r.ipD[0];\par
00922             {\cf19 break};\par
00923           {\cf19 default}:\par
00924             {\cf19 break};\par
00925         \}\par
00926         {\cf18 int} ip_idx = mask == 8 ? ip : 256;\par
00927         {\cf19 if} (node->child[ip_idx].pointer == NULL)\par
00928           {\cf19 return} {\cf17 false};\par
00929         {\cf19 else} \{\par
00930           LeafNode* ln = (LeafNode*)node->child[ip_idx].pointer;\par
00931           {\cf19 for} ({\cf18 int} i = 0; i < ln->Rule_5D.size(); ++i) \{\par
00932             {\cf19 if} (ln->Rule_5D[i].pri == r.pri) \{\par
00933               ln->Rule_5D.erase(ln->Rule_5D.begin() + i);\par
00934               {\cf19 return} {\cf17 true};\par
00935             \}\par
00936           \}\par
00937           {\cf19 return} {\cf17 false};\par
00938         \}\par
00939       \}\par
00940       {\cf19 default}: \{\par
00941         {\cf19 if} (pTree == NULL) \{\par
00942           {\cf19 return} {\cf17 false};\par
00943         \}\par
00944         IpNode* node = (IpNode*)pTree;\par
00945         {\cf18 int} totalLayer = layerFields.size();\par
00946         {\cf18 int} layer = 0;\par
00947         {\cf18 unsigned} {\cf18 int} mask, ip;\par
00948         {\cf19 while} (layer < totalLayer - 1) \{\par
00949           {\cf19 switch} (node->field) \{\par
00950             {\cf19 case} 0:\par
00951               mask = maskHash[({\cf18 unsigned} int)r.ipSMask][0];\par
00952               ip = ({\cf18 unsigned} int)r.ipS[3] >> (8 - mask);\par
00953               {\cf19 break};\par
00954             {\cf19 case} 1:\par
00955               mask = maskHash[({\cf18 unsigned} int)r.ipSMask][1];\par
00956               ip = ({\cf18 unsigned} int)r.ipS[2] >> (8 - mask);\par
00957               {\cf19 break};\par
00958             {\cf19 case} 2:\par
00959               mask = maskHash[({\cf18 unsigned} int)r.ipSMask][2];\par
00960               ip = ({\cf18 unsigned} int)r.ipS[1] >> (8 - mask);\par
00961               {\cf19 break};\par
00962             {\cf19 case} 3:\par
00963               mask = maskHash[({\cf18 unsigned} int)r.ipSMask][3];\par
00964               ip = ({\cf18 unsigned} int)r.ipS[0] >> (8 - mask);\par
00965               {\cf19 break};\par
00966             {\cf19 case} 4:\par
00967               mask = maskHash[({\cf18 unsigned} int)r.ipDMask][0];\par
00968               ip = ({\cf18 unsigned} int)r.ipD[3] >> (8 - mask);\par
00969               {\cf19 break};\par
00970             {\cf19 case} 5:\par
00971               mask = maskHash[({\cf18 unsigned} int)r.ipDMask][1];\par
00972               ip = ({\cf18 unsigned} int)r.ipD[2] >> (8 - mask);\par
00973               {\cf19 break};\par
00974             {\cf19 case} 6:\par
00975               mask = maskHash[({\cf18 unsigned} int)r.ipDMask][2];\par
00976               ip = ({\cf18 unsigned} int)r.ipD[1] >> (8 - mask);\par
00977               {\cf19 break};\par
00978             {\cf19 case} 7:\par
00979               mask = maskHash[({\cf18 unsigned} int)r.ipDMask][3];\par
00980               ip = ({\cf18 unsigned} int)r.ipD[0] >> (8 - mask);\par
00981               {\cf19 break};\par
00982             {\cf19 default}:\par
00983               {\cf19 break};\par
00984           \}\par
00985           std::vector<IpTable>::iterator it = node->tableList.begin();\par
00986           {\cf19 for} (; it != node->tableList.end(); ++it) \{\par
00987             {\cf19 if} (mask == it->mask) \{       {\cf20 // have table}\par
00988               {\cf19 if} (it->table[ip] == -1) \{  {\cf20 // no child}\par
00989                 {\cf19 return} {\cf17 false};\par
00990               \} {\cf19 else} \{\par
00991                 node = (IpNode*)(it->child[it->table[ip]].second);\par
00992                 {\cf19 break};\par
00993               \}\par
00994             \}\par
00995             {\cf19 if} (mask > it->mask) \{  {\cf20 // find the site}\par
00996               {\cf19 break};\par
00997             \}\par
00998           \}\par
00999           {\cf19 if} (it == node->tableList.end() || mask != it->mask) \{  {\cf20 // no table}\par
01000             {\cf19 return} {\cf17 false};\par
01001           \}\par
01002           ++layer;\par
01003         \}\par
01004         {\cf20 // process leafnode}\par
01005         node->childType = 1;\par
01006         {\cf19 switch} (node->field) \{\par
01007           {\cf19 case} 0:\par
01008             mask = maskHash[({\cf18 unsigned} int)r.ipSMask][0];\par
01009             ip = ({\cf18 unsigned} int)r.ipS[3] >> (8 - mask);\par
01010             {\cf19 break};\par
01011           {\cf19 case} 1:\par
01012             mask = maskHash[({\cf18 unsigned} int)r.ipSMask][1];\par
01013             ip = ({\cf18 unsigned} int)r.ipS[2] >> (8 - mask);\par
01014             {\cf19 break};\par
01015           {\cf19 case} 2:\par
01016             mask = maskHash[({\cf18 unsigned} int)r.ipSMask][2];\par
01017             ip = ({\cf18 unsigned} int)r.ipS[1] >> (8 - mask);\par
01018             {\cf19 break};\par
01019           {\cf19 case} 3:\par
01020             mask = maskHash[({\cf18 unsigned} int)r.ipSMask][3];\par
01021             ip = ({\cf18 unsigned} int)r.ipS[0] >> (8 - mask);\par
01022             {\cf19 break};\par
01023           {\cf19 case} 4:\par
01024             mask = maskHash[({\cf18 unsigned} int)r.ipDMask][0];\par
01025             ip = ({\cf18 unsigned} int)r.ipD[3] >> (8 - mask);\par
01026             {\cf19 break};\par
01027           {\cf19 case} 5:\par
01028             mask = maskHash[({\cf18 unsigned} int)r.ipDMask][1];\par
01029             ip = ({\cf18 unsigned} int)r.ipD[2] >> (8 - mask);\par
01030             {\cf19 break};\par
01031           {\cf19 case} 6:\par
01032             mask = maskHash[({\cf18 unsigned} int)r.ipDMask][2];\par
01033             ip = ({\cf18 unsigned} int)r.ipD[1] >> (8 - mask);\par
01034             {\cf19 break};\par
01035           {\cf19 case} 7:\par
01036             mask = maskHash[({\cf18 unsigned} int)r.ipDMask][3];\par
01037             ip = ({\cf18 unsigned} int)r.ipD[0] >> (8 - mask);\par
01038             {\cf19 break};\par
01039           {\cf19 default}:\par
01040             {\cf19 break};\par
01041         \}\par
01042         std::vector<IpTable>::iterator it = node->tableList.begin();\par
01043         {\cf19 for} (; it != node->tableList.end(); ++it) \{\par
01044           {\cf19 if} (mask == it->mask) \{       {\cf20 // have table}\par
01045             {\cf19 if} (it->table[ip] == -1) \{  {\cf20 // no child}\par
01046               {\cf19 return} {\cf17 false};\par
01047             \} {\cf19 else} \{\par
01048               LeafNode* ln = ((LeafNode*)(it->child[it->table[ip]].second));\par
01049               {\cf19 for} ({\cf18 int} i = 0; i < ln->Rule_5D.size(); ++i) \{\par
01050                 {\cf19 if} (ln->Rule_5D[i].pri == r.pri) \{\par
01051                   ln->Rule_5D.erase(ln->Rule_5D.begin() + i);\par
01052                   {\cf19 return} {\cf17 true};\par
01053                 \}\par
01054               \}\par
01055               {\cf19 break};\par
01056             \}\par
01057           \}\par
01058           {\cf19 if} (mask > it->mask) \{  {\cf20 // find the site}\par
01059             {\cf19 break};\par
01060           \}\par
01061         \}\par
01062         {\cf19 return} {\cf17 false};\par
01063       \}\par
01064     \}\par
01065   \}\par
01066 \}\par
01067 \par
01068 {\cf18 int} PTtree::search(Packet_5D& p) \{\par
01069   {\cf18 unsigned} {\cf18 int} pSip, pDip;\par
01070   {\cf18 unsigned} {\cf18 char} pProto;\par
01071   {\cf18 unsigned} {\cf18 short} pSport, pDport;\par
01072   pProto = p.protocol;\par
01073   memcpy(&pSip, p.ipS, 4);\par
01074   memcpy(&pDip, p.ipD, 4);\par
01075   pSport = p.portS;\par
01076   pDport = p.portD;\par
01077 \par
01078   {\cf18 unsigned} {\cf18 int} mip[4];\par
01079   {\cf19 for} ({\cf18 int} i = 0; i < layerFields.size(); ++i) \{\par
01080     {\cf19 switch} (layerFields[i]) \{\par
01081       {\cf19 case} 0:\par
01082         mip[i] = ({\cf18 unsigned} int)p.ipS[3];\par
01083         {\cf19 break};\par
01084       {\cf19 case} 1:\par
01085         mip[i] = ({\cf18 unsigned} int)p.ipS[2];\par
01086         {\cf19 break};\par
01087       {\cf19 case} 2:\par
01088         mip[i] = ({\cf18 unsigned} int)p.ipS[1];\par
01089         {\cf19 break};\par
01090       {\cf19 case} 3:\par
01091         mip[i] = ({\cf18 unsigned} int)p.ipS[0];\par
01092         {\cf19 break};\par
01093       {\cf19 case} 4:\par
01094         mip[i] = ({\cf18 unsigned} int)p.ipD[3];\par
01095         {\cf19 break};\par
01096       {\cf19 case} 5:\par
01097         mip[i] = ({\cf18 unsigned} int)p.ipD[2];\par
01098         {\cf19 break};\par
01099       {\cf19 case} 6:\par
01100         mip[i] = ({\cf18 unsigned} int)p.ipD[1];\par
01101         {\cf19 break};\par
01102       {\cf19 case} 7:\par
01103         mip[i] = ({\cf18 unsigned} int)p.ipD[0];\par
01104         {\cf19 break};\par
01105       {\cf19 default}:\par
01106         {\cf19 break};\par
01107     \}\par
01108   \}\par
01109   {\cf18 unsigned} {\cf18 int} res = 0xFFFFFFFF;\par
01110 \par
01111   {\cf20 // search in pTree}\par
01112   {\cf19 switch} (layerFields.size()) \{\par
01113     {\cf19 case} 3: \{\par
01114       IpNode_static* node_1 = (IpNode_static*)pTree;\par
01115       {\cf18 unsigned} {\cf18 int} i_1[2] = \{mip[0], 256\};\par
01116       {\cf19 for} ({\cf18 int} i = 0; i < 2; ++i) \{\par
01117         {\cf19 if} (node_1->child[i_1[i]].pointer == NULL ||\par
01118             node_1->child[i_1[i]].pri > res)\par
01119           {\cf19 continue};\par
01120         IpNode_static* node_2 = (IpNode_static*)node_1->child[i_1[i]].pointer;\par
01121         {\cf18 unsigned} {\cf18 int} i_2[2] = \{mip[1], 256\};\par
01122         {\cf19 for} ({\cf18 int} j = 0; j < 2; ++j) \{\par
01123           {\cf19 if} (node_2->child[i_2[j]].pointer == NULL ||\par
01124               node_2->child[i_2[j]].pri > res)\par
01125             {\cf19 continue};\par
01126           IpNode_static* node_3 = (IpNode_static*)node_2->child[i_2[j]].pointer;\par
01127           {\cf18 unsigned} {\cf18 int} i_3[2] = \{mip[2], 256\};\par
01128           {\cf19 for} ({\cf18 int} k = 0; k < 2; ++k) \{\par
01129             {\cf19 if} (node_3->child[i_3[k]].pointer == NULL ||\par
01130                 node_3->child[i_3[k]].pri > res)\par
01131               {\cf19 continue};\par
01132             LeafNode* ln = (LeafNode*)node_3->child[i_3[k]].pointer;\par
01133             {\cf19 for} ({\cf17 auto}&& r : ln->Rule_5D) \{\par
01134               {\cf19 if} (res < r.pri) {\cf19 break};\par
01135               {\cf19 if} (pProto != r.protocol[1] && r.protocol[0] != 0)\par
01136                 {\cf19 continue};  {\cf20 // check protocol}\par
01137               {\cf19 if} (pDport < r.portD[0] || r.portD[1] < pDport)\par
01138                 {\cf19 continue};  {\cf20 // if destination port not match, check next}\par
01139               {\cf19 if} (pSport < r.portS[0] || r.portS[1] < pSport)\par
01140                 {\cf19 continue};  {\cf20 // if source port not match, check next}\par
01141               {\cf18 unsigned} {\cf18 int} m_bit =\par
01142                   32 - ({\cf18 unsigned} int)\par
01143                            r.ipDMask;  {\cf20 // comput the bit number need to move}\par
01144               {\cf18 unsigned} {\cf18 int} _ip;\par
01145               {\cf19 if} (m_bit != 32) \{\par
01146                 memcpy(&_ip, r.ipD, 4);\par
01147                 {\cf19 if} (pDip >> m_bit != _ip >> m_bit)\par
01148                   {\cf19 continue};  {\cf20 // if destination ip not match, check next}\par
01149               \}\par
01150               m_bit = 32 - ({\cf18 unsigned} int)\par
01151                                r.ipSMask;  {\cf20 // comput the bit number need to move}\par
01152               {\cf19 if} (m_bit != 32) \{\par
01153                 memcpy(&_ip, r.ipS, 4);\par
01154                 {\cf19 if} (pSip >> m_bit != _ip >> m_bit)\par
01155                   {\cf19 continue};  {\cf20 // if source ip not match, check next}\par
01156               \}\par
01157               res = r.pri;\par
01158               {\cf19 break};\par
01159             \}\par
01160           \}\par
01161         \}\par
01162       \}\par
01163       {\cf19 break};\par
01164     \}\par
01165     {\cf19 case} 4: \{\par
01166       IpNode* node_1 = (IpNode*)pTree;\par
01167       {\cf18 unsigned} {\cf18 int} ip_idx = 0;\par
01168       {\cf19 for} (std::vector<IpTable>::iterator it_1 = node_1->tableList.begin();\par
01169            it_1 != node_1->tableList.end(); ++it_1) \{\par
01170         ip_idx = mip[0] >> (8 - it_1->mask);\par
01171         {\cf19 if} (it_1->pri > res || it_1->table[ip_idx] == -1 ||\par
01172             it_1->child[it_1->table[ip_idx]].first > res)\par
01173           {\cf19 continue};\par
01174         IpNode* node_2 = (IpNode*)(it_1->child[it_1->table[ip_idx]].second);\par
01175         {\cf19 for} (std::vector<IpTable>::iterator it_2 = node_2->tableList.begin();\par
01176              it_2 != node_2->tableList.end(); ++it_2) \{\par
01177           ip_idx = mip[1] >> (8 - it_2->mask);\par
01178           {\cf19 if} (it_2->pri > res || it_2->table[ip_idx] == -1 ||\par
01179               it_2->child[it_2->table[ip_idx]].first > res)\par
01180             {\cf19 continue};\par
01181           IpNode* node_3 = (IpNode*)(it_2->child[it_2->table[ip_idx]].second);\par
01182           {\cf19 for} (std::vector<IpTable>::iterator it_3 = node_3->tableList.begin();\par
01183                it_3 != node_3->tableList.end(); ++it_3) \{\par
01184             ip_idx = mip[2] >> (8 - it_3->mask);\par
01185             {\cf19 if} (it_3->pri > res || it_3->table[ip_idx] == -1 ||\par
01186                 it_3->child[it_3->table[ip_idx]].first > res)\par
01187               {\cf19 continue};\par
01188             IpNode* node_4 = (IpNode*)(it_3->child[it_3->table[ip_idx]].second);\par
01189             {\cf19 for} (std::vector<IpTable>::iterator it_4 =\par
01190                      node_4->tableList.begin();\par
01191                  it_4 != node_4->tableList.end(); ++it_4) \{\par
01192               ip_idx = mip[3] >> (8 - it_4->mask);\par
01193               {\cf19 if} (it_4->pri > res || it_4->table[ip_idx] == -1 ||\par
01194                   it_4->child[it_4->table[ip_idx]].first > res)\par
01195                 {\cf19 continue};\par
01196               LeafNode* ln =\par
01197                   (LeafNode*)(it_4->child[it_4->table[ip_idx]].second);\par
01198               {\cf19 for} ({\cf17 auto}&& r : ln->Rule_5D) \{\par
01199                 {\cf19 if} (res < r.pri) {\cf19 break};\par
01200                 {\cf19 if} (pProto != r.protocol[1] && r.protocol[0] != 0)\par
01201                   {\cf19 continue};  {\cf20 // check protocol}\par
01202                 {\cf19 if} (pDport < r.portD[0] || r.portD[1] < pDport)\par
01203                   {\cf19 continue};  {\cf20 // if destination port not match, check next}\par
01204                 {\cf19 if} (pSport < r.portS[0] || r.portS[1] < pSport)\par
01205                   {\cf19 continue};  {\cf20 // if source port not match, check next}\par
01206                 {\cf18 unsigned} {\cf18 int} m_bit =\par
01207                     32 - ({\cf18 unsigned} int)r.ipDMask;  {\cf20 // comput the bit number}\par
01208                                                    {\cf20 // need to move}\par
01209                 {\cf18 unsigned} {\cf18 int} _ip;\par
01210                 {\cf19 if} (m_bit != 32) \{\par
01211                   memcpy(&_ip, r.ipD, 4);\par
01212                   {\cf19 if} (pDip >> m_bit != _ip >> m_bit)\par
01213                     {\cf19 continue};  {\cf20 // if destination ip not match, check next}\par
01214                 \}\par
01215                 m_bit =\par
01216                     32 - ({\cf18 unsigned} int)\par
01217                              r.ipSMask;  {\cf20 // comput the bit number need to move}\par
01218                 {\cf19 if} (m_bit != 32) \{\par
01219                   memcpy(&_ip, r.ipS, 4);\par
01220                   {\cf19 if} (pSip >> m_bit != _ip >> m_bit)\par
01221                     {\cf19 continue};  {\cf20 // if source ip not match, check next}\par
01222                 \}\par
01223                 res = r.pri;\par
01224                 {\cf19 break};\par
01225               \}\par
01226             \}\par
01227           \}\par
01228         \}\par
01229       \}\par
01230       {\cf19 break};\par
01231     \}\par
01232     {\cf19 default}:\par
01233       {\cf19 break};\par
01234   \}\par
01235 \par
01236   {\cf19 if} (aTree != NULL) \{\par
01237     {\cf18 int} proto_idx[2] = \{aTree->table[pProto], aTree->table[0]\};\par
01238     {\cf18 int} port_idx[2];\par
01239     {\cf19 for} ({\cf18 int} i = 0; i < 2; ++i) \{\par
01240       {\cf19 if} (proto_idx[i] != -1 && res > aTree->child[proto_idx[i]].first) \{\par
01241         PortNode_static* pnode =\par
01242             (PortNode_static*)aTree->child[proto_idx[i]].second;\par
01243         {\cf19 if} (portField == 0)\par
01244           port_idx[0] = pnode->table[pSport / 2];\par
01245         {\cf19 else}\par
01246           port_idx[0] = pnode->table[pDport / 2];\par
01247         port_idx[1] = pnode->table[32768];\par
01248         {\cf19 for} ({\cf18 int} j = 0; j < 2; ++j) \{\par
01249           {\cf19 if} (port_idx[j] != -1 && res > pnode->child[port_idx[j]].first) \{\par
01250             LeafNode* ln = pnode->child[port_idx[j]].second;\par
01251             {\cf19 for} ({\cf17 auto}&& r : ln->Rule_5D) \{\par
01252               {\cf19 if} (res < r.pri) {\cf19 break};\par
01253               {\cf19 if} (pDport < r.portD[0] || r.portD[1] < pDport)\par
01254                 {\cf19 continue};  {\cf20 // if destination port not match, check next}\par
01255               {\cf19 if} (pSport < r.portS[0] || r.portS[1] < pSport)\par
01256                 {\cf19 continue};  {\cf20 // if source port not match, check next}\par
01257               {\cf18 unsigned} {\cf18 int} m_bit =\par
01258                   32 - ({\cf18 unsigned} int)\par
01259                            r.ipDMask;  {\cf20 // comput the bit number need to move}\par
01260               {\cf18 unsigned} {\cf18 int} _ip;\par
01261               {\cf19 if} (m_bit != 32) \{\par
01262                 memcpy(&_ip, r.ipD, 4);\par
01263                 {\cf19 if} (pDip >> m_bit != _ip >> m_bit)\par
01264                   {\cf19 continue};  {\cf20 // if destination ip not match, check next}\par
01265               \}\par
01266               m_bit = 32 - ({\cf18 unsigned} int)\par
01267                                r.ipSMask;  {\cf20 // comput the bit number need to move}\par
01268               {\cf19 if} (m_bit != 32) \{\par
01269                 memcpy(&_ip, r.ipS, 4);\par
01270                 {\cf19 if} (pSip >> m_bit != _ip >> m_bit)\par
01271                   {\cf19 continue};  {\cf20 // if source ip not match, check next}\par
01272               \}\par
01273               res = r.pri;\par
01274               {\cf19 break};\par
01275             \}\par
01276           \}\par
01277         \}\par
01278       \}\par
01279     \}\par
01280   \}\par
01281   {\cf19 return} res;\par
01282 \}\par
01283 \par
01284 {\cf18 int} PTtree::search_with_log(Packet_5D& p, ACL_LOG& log) \{\par
01285   {\cf18 unsigned} {\cf18 int} pSip, pDip;\par
01286   {\cf18 unsigned} {\cf18 char} pProto;\par
01287   {\cf18 unsigned} {\cf18 short} pSport, pDport;\par
01288   pProto = p.protocol;\par
01289   memcpy(&pSip, p.ipS, 4);\par
01290   memcpy(&pDip, p.ipD, 4);\par
01291   pSport = p.portS;\par
01292   pDport = p.portD;\par
01293 \par
01294   {\cf18 unsigned} {\cf18 int} mip[4];\par
01295   {\cf19 for} ({\cf18 int} i = 0; i < layerFields.size(); ++i) \{\par
01296     {\cf19 switch} (layerFields[i]) \{\par
01297       {\cf19 case} 0:\par
01298         mip[i] = ({\cf18 unsigned} int)p.ipS[3];\par
01299         {\cf19 break};\par
01300       {\cf19 case} 1:\par
01301         mip[i] = ({\cf18 unsigned} int)p.ipS[2];\par
01302         {\cf19 break};\par
01303       {\cf19 case} 2:\par
01304         mip[i] = ({\cf18 unsigned} int)p.ipS[1];\par
01305         {\cf19 break};\par
01306       {\cf19 case} 3:\par
01307         mip[i] = ({\cf18 unsigned} int)p.ipS[0];\par
01308         {\cf19 break};\par
01309       {\cf19 case} 4:\par
01310         mip[i] = ({\cf18 unsigned} int)p.ipD[3];\par
01311         {\cf19 break};\par
01312       {\cf19 case} 5:\par
01313         mip[i] = ({\cf18 unsigned} int)p.ipD[2];\par
01314         {\cf19 break};\par
01315       {\cf19 case} 6:\par
01316         mip[i] = ({\cf18 unsigned} int)p.ipD[1];\par
01317         {\cf19 break};\par
01318       {\cf19 case} 7:\par
01319         mip[i] = ({\cf18 unsigned} int)p.ipD[0];\par
01320         {\cf19 break};\par
01321       {\cf19 default}:\par
01322         {\cf19 break};\par
01323     \}\par
01324   \}\par
01325   {\cf18 unsigned} {\cf18 int} res = 0xFFFFFFFF;\par
01326 \par
01327   {\cf20 // search in pTree}\par
01328   {\cf19 if} (pTree != NULL) \{\par
01329     {\cf19 switch} (layerFields.size()) \{\par
01330       {\cf19 case} 3: \{\par
01331         IpNode_static* node_1 = (IpNode_static*)pTree;\par
01332         {\cf18 unsigned} {\cf18 int} i_1[2] = \{mip[0], 256\};\par
01333         log.ipNodeList.emplace_back(node_1);\par
01334         {\cf19 for} ({\cf18 int} i = 0; i < 2; ++i) \{\par
01335           {\cf19 if} (node_1->child[i_1[i]].pointer == NULL ||\par
01336               node_1->child[i_1[i]].pri > res)\par
01337             {\cf19 continue};\par
01338           IpNode_static* node_2 = (IpNode_static*)node_1->child[i_1[i]].pointer;\par
01339           {\cf18 unsigned} {\cf18 int} i_2[2] = \{mip[1], 256\};\par
01340           log.ipNodeList.emplace_back(node_2);\par
01341           {\cf19 for} ({\cf18 int} j = 0; j < 2; ++j) \{\par
01342             {\cf19 if} (node_2->child[i_2[j]].pointer == NULL ||\par
01343                 node_2->child[i_2[j]].pri > res)\par
01344               {\cf19 continue};\par
01345             IpNode_static* node_3 =\par
01346                 (IpNode_static*)node_2->child[i_2[j]].pointer;\par
01347             {\cf18 unsigned} {\cf18 int} i_3[2] = \{mip[2], 256\};\par
01348             log.ipNodeList.emplace_back(node_3);\par
01349             {\cf19 for} ({\cf18 int} k = 0; k < 2; ++k) \{\par
01350               {\cf19 if} (node_3->child[i_3[k]].pointer == NULL ||\par
01351                   node_3->child[i_3[k]].pri > res)\par
01352                 {\cf19 continue};\par
01353               LeafNode* ln = (LeafNode*)node_3->child[i_3[k]].pointer;\par
01354               log.pLeafNodeList.emplace_back(ln);\par
01355               {\cf19 for} ({\cf17 auto}&& r : ln->Rule_5D) \{\par
01356                 ++log.rules;\par
01357                 {\cf19 if} (res < r.pri) {\cf19 break};\par
01358                 {\cf19 if} (pProto != r.protocol[1] && r.protocol[0] != 0)\par
01359                   {\cf19 continue};  {\cf20 // check protocol}\par
01360                 {\cf19 if} (pDport < r.portD[0] || r.portD[1] < pDport)\par
01361                   {\cf19 continue};  {\cf20 // if destination port not match, check next}\par
01362                 {\cf19 if} (pSport < r.portS[0] || r.portS[1] < pSport)\par
01363                   {\cf19 continue};  {\cf20 // if source port not match, check next}\par
01364                 {\cf18 unsigned} {\cf18 int} m_bit =\par
01365                     32 - ({\cf18 unsigned} int)r.ipDMask;  {\cf20 // comput the bit number}\par
01366                                                    {\cf20 // need to move}\par
01367                 {\cf18 unsigned} {\cf18 int} _ip;\par
01368                 {\cf19 if} (m_bit != 32) \{\par
01369                   memcpy(&_ip, r.ipD, 4);\par
01370                   {\cf19 if} (pDip >> m_bit != _ip >> m_bit)\par
01371                     {\cf19 continue};  {\cf20 // if destination ip not match, check next}\par
01372                 \}\par
01373                 m_bit =\par
01374                     32 - ({\cf18 unsigned} int)\par
01375                              r.ipSMask;  {\cf20 // comput the bit number need to move}\par
01376                 {\cf19 if} (m_bit != 32) \{\par
01377                   memcpy(&_ip, r.ipS, 4);\par
01378                   {\cf19 if} (pSip >> m_bit != _ip >> m_bit)\par
01379                     {\cf19 continue};  {\cf20 // if source ip not match, check next}\par
01380                 \}\par
01381                 res = r.pri;\par
01382                 {\cf19 break};\par
01383               \}\par
01384             \}\par
01385           \}\par
01386         \}\par
01387         log.tables += log.ipNodeList.size();\par
01388         {\cf19 break};\par
01389       \}\par
01390       {\cf19 case} 4: \{\par
01391         IpNode* node_1 = (IpNode*)pTree;\par
01392         {\cf18 unsigned} {\cf18 int} ip_idx = 0;\par
01393         log.ipNodeList.emplace_back(node_1);\par
01394         {\cf19 for} (std::vector<IpTable>::iterator it_1 = node_1->tableList.begin();\par
01395              it_1 != node_1->tableList.end(); ++it_1) \{\par
01396           ip_idx = mip[0] >> (8 - it_1->mask);\par
01397           {\cf19 if} (it_1->pri > res) {\cf19 continue};\par
01398           ++log.tables;\par
01399           {\cf19 if} (it_1->table[ip_idx] == -1 ||\par
01400               it_1->child[it_1->table[ip_idx]].first > res)\par
01401             {\cf19 continue};\par
01402           IpNode* node_2 = (IpNode*)(it_1->child[it_1->table[ip_idx]].second);\par
01403           log.ipNodeList.emplace_back(node_2);\par
01404           {\cf19 for} (std::vector<IpTable>::iterator it_2 = node_2->tableList.begin();\par
01405                it_2 != node_2->tableList.end(); ++it_2) \{\par
01406             ip_idx = mip[1] >> (8 - it_2->mask);\par
01407             {\cf19 if} (it_2->pri > res) {\cf19 continue};\par
01408             ++log.tables;\par
01409             {\cf19 if} (it_2->table[ip_idx] == -1 ||\par
01410                 it_2->child[it_2->table[ip_idx]].first > res)\par
01411               {\cf19 continue};\par
01412             IpNode* node_3 = (IpNode*)(it_2->child[it_2->table[ip_idx]].second);\par
01413             log.ipNodeList.emplace_back(node_3);\par
01414             {\cf19 for} (std::vector<IpTable>::iterator it_3 =\par
01415                      node_3->tableList.begin();\par
01416                  it_3 != node_3->tableList.end(); ++it_3) \{\par
01417               ip_idx = mip[2] >> (8 - it_3->mask);\par
01418               {\cf19 if} (it_3->pri > res) {\cf19 continue};\par
01419               ++log.tables;\par
01420               {\cf19 if} (it_3->table[ip_idx] == -1 ||\par
01421                   it_3->child[it_3->table[ip_idx]].first > res)\par
01422                 {\cf19 continue};\par
01423               IpNode* node_4 =\par
01424                   (IpNode*)(it_3->child[it_3->table[ip_idx]].second);\par
01425               log.ipNodeList.emplace_back(node_4);\par
01426               {\cf19 for} (std::vector<IpTable>::iterator it_4 =\par
01427                        node_4->tableList.begin();\par
01428                    it_4 != node_4->tableList.end(); ++it_4) \{\par
01429                 ip_idx = mip[3] >> (8 - it_4->mask);\par
01430                 {\cf19 if} (it_4->pri > res) {\cf19 continue};\par
01431                 ++log.tables;\par
01432                 {\cf19 if} (it_4->table[ip_idx] == -1 ||\par
01433                     it_4->child[it_4->table[ip_idx]].first > res)\par
01434                   {\cf19 continue};\par
01435                 LeafNode* ln =\par
01436                     (LeafNode*)(it_4->child[it_4->table[ip_idx]].second);\par
01437                 log.pLeafNodeList.emplace_back(ln);\par
01438                 {\cf19 for} ({\cf17 auto}&& r : ln->Rule_5D) \{\par
01439                   ++log.rules;\par
01440                   {\cf19 if} (res < r.pri) {\cf19 break};\par
01441                   {\cf19 if} (pProto != r.protocol[1] && r.protocol[0] != 0)\par
01442                     {\cf19 continue};  {\cf20 // check protocol}\par
01443                   {\cf19 if} (pDport < r.portD[0] || r.portD[1] < pDport)\par
01444                     {\cf19 continue};  {\cf20 // if destination port not match, check next}\par
01445                   {\cf19 if} (pSport < r.portS[0] || r.portS[1] < pSport)\par
01446                     {\cf19 continue};  {\cf20 // if source port not match, check next}\par
01447                   {\cf18 unsigned} {\cf18 int} m_bit =\par
01448                       32 - ({\cf18 unsigned} int)r.ipDMask;  {\cf20 // comput the bit}\par
01449                                                      {\cf20 // number need to move}\par
01450                   {\cf18 unsigned} {\cf18 int} _ip;\par
01451                   {\cf19 if} (m_bit != 32) \{\par
01452                     memcpy(&_ip, r.ipD, 4);\par
01453                     {\cf19 if} (pDip >> m_bit != _ip >> m_bit)\par
01454                       {\cf19 continue};  {\cf20 // if destination ip not match, check next}\par
01455                   \}\par
01456                   m_bit =\par
01457                       32 - ({\cf18 unsigned} int)\par
01458                                r.ipSMask;  {\cf20 // comput the bit number need to move}\par
01459                   {\cf19 if} (m_bit != 32) \{\par
01460                     memcpy(&_ip, r.ipS, 4);\par
01461                     {\cf19 if} (pSip >> m_bit != _ip >> m_bit)\par
01462                       {\cf19 continue};  {\cf20 // if source ip not match, check next}\par
01463                   \}\par
01464                   res = r.pri;\par
01465                   {\cf19 break};\par
01466                 \}\par
01467               \}\par
01468             \}\par
01469           \}\par
01470         \}\par
01471         {\cf19 break};\par
01472       \}\par
01473       {\cf19 default}:\par
01474         {\cf19 break};\par
01475     \}\par
01476   \}\par
01477 \par
01478   {\cf19 if} (aTree != NULL) \{\par
01479     {\cf18 int} proto_idx[2] = \{aTree->table[pProto], aTree->table[0]\};\par
01480     {\cf18 int} port_idx[2];\par
01481     {\cf19 for} ({\cf18 int} i = 0; i < 2; ++i) \{\par
01482       {\cf19 if} (proto_idx[i] != -1 && res > aTree->child[proto_idx[i]].first) \{\par
01483         PortNode_static* pnode =\par
01484             (PortNode_static*)aTree->child[proto_idx[i]].second;\par
01485         {\cf19 if} (portField == 0)\par
01486           port_idx[0] = pnode->table[pSport / 2];\par
01487         {\cf19 else}\par
01488           port_idx[0] = pnode->table[pDport / 2];\par
01489         port_idx[1] = pnode->table[32768];\par
01490         log.portNodeList.emplace_back(pnode);\par
01491         {\cf19 for} ({\cf18 int} j = 0; j < 2; ++j) \{\par
01492           {\cf19 if} (port_idx[j] != -1 && res > pnode->child[port_idx[j]].first) \{\par
01493             LeafNode* ln = pnode->child[port_idx[j]].second;\par
01494             log.aLeafNodeList.emplace_back(ln);\par
01495             {\cf19 for} ({\cf17 auto}&& r : ln->Rule_5D) \{\par
01496               ++log.rules;\par
01497               {\cf19 if} (res < r.pri) {\cf19 break};\par
01498               {\cf19 if} (pDport < r.portD[0] || r.portD[1] < pDport)\par
01499                 {\cf19 continue};  {\cf20 // if destination port not match, check next}\par
01500               {\cf19 if} (pSport < r.portS[0] || r.portS[1] < pSport)\par
01501                 {\cf19 continue};  {\cf20 // if source port not match, check next}\par
01502               {\cf18 unsigned} {\cf18 int} m_bit =\par
01503                   32 - ({\cf18 unsigned} int)\par
01504                            r.ipDMask;  {\cf20 // comput the bit number need to move}\par
01505               {\cf18 unsigned} {\cf18 int} _ip;\par
01506               {\cf19 if} (m_bit != 32) \{\par
01507                 memcpy(&_ip, r.ipD, 4);\par
01508                 {\cf19 if} (pDip >> m_bit != _ip >> m_bit)\par
01509                   {\cf19 continue};  {\cf20 // if destination ip not match, check next}\par
01510               \}\par
01511               m_bit = 32 - ({\cf18 unsigned} int)\par
01512                                r.ipSMask;  {\cf20 // comput the bit number need to move}\par
01513               {\cf19 if} (m_bit != 32) \{\par
01514                 memcpy(&_ip, r.ipS, 4);\par
01515                 {\cf19 if} (pSip >> m_bit != _ip >> m_bit)\par
01516                   {\cf19 continue};  {\cf20 // if source ip not match, check next}\par
01517               \}\par
01518               res = r.pri;\par
01519               {\cf19 break};\par
01520             \}\par
01521           \}\par
01522         \}\par
01523       \}\par
01524     \}\par
01525   \}\par
01526 \par
01527   log.tables += log.portNodeList.size() + 1;\par
01528   log.innerNodes = log.ipNodeList.size() + log.portNodeList.size() + 1;\par
01529   log.leafNodes = log.pLeafNodeList.size() + log.aLeafNodeList.size();\par
01530 \par
01531   {\cf19 return} res;\par
01532 \}\par
01533 \par
01534 {\cf18 bool} PTtree::update(std::vector<Rule_5D>& rules, {\cf18 int} num, {\cf17 struct} timespec& t1,\par
01535                     {\cf17 struct} timespec& t2) \{\par
01536   {\cf18 int} ruleNum = rules.size();\par
01537   std::vector<Rule_5D> newRule;\par
01538   std::vector<int> rd_idx;\par
01539   std::random_device seed;\par
01540   std::mt19937 rd(seed());\par
01541   std::uniform_int_distribution<> dis(0, ruleNum * 0.7);\par
01542   {\cf19 for} ({\cf18 int} i = 0; i < num; ++i) \{\par
01543     {\cf18 int} cur_idx = dis(rd);\par
01544     {\cf19 while} (find(rd_idx.begin(), rd_idx.end(), cur_idx) != rd_idx.end())\par
01545       cur_idx = dis(rd);\par
01546     Rule_5D r = rules[cur_idx];\par
01547     newRule.emplace_back(r);\par
01548     rd_idx.emplace_back(cur_idx);\par
01549   \}\par
01550 \par
01551   clock_gettime(CLOCK_REALTIME, &t1);\par
01552   {\cf20 // remove}\par
01553   {\cf19 for} ({\cf18 int} i = 0; i < num; ++i) \{\par
01554     {\cf18 bool} res = this->remove(rules[i]);\par
01555     {\cf19 if} (!res) \{\par
01556       fprintf(stderr, {\cf22 "error-can not find Rule_5D! Remove rules failed!"});\par
01557       {\cf19 return} res;\par
01558     \}\par
01559   \}\par
01560   {\cf20 // insert}\par
01561   {\cf19 for} ({\cf18 int} i = 0; i < num; ++i) \{\par
01562     this->insert_up(newRule[i]);\par
01563   \}\par
01564   clock_gettime(CLOCK_REALTIME, &t2);\par
01565   {\cf19 return} {\cf17 true};\par
01566 \}\par
01567 \par
01568 {\cf18 void} PTtree::print_node_info({\cf18 int} level, {\cf18 int} rules) \{\par
01569   std::cout << {\cf22 "|- Total nodes num:          "} << this->totalNodes << std::endl;\par
01570   std::cout << {\cf22 "|- Total inner nodes num:    "}\par
01571             << this->ipNodeList.size() + this->portNodeList.size() + 1\par
01572             << std::endl;\par
01573   std::cout << {\cf22 "|- Total leaf nodes num:     "}\par
01574             << this->pLeafNodeList.size() + this->aLeafNodeList.size()\par
01575             << std::endl;\par
01576   std::cout << {\cf22 "|- IpNode num:               "} << this->ipNodeList.size()\par
01577             << std::endl;\par
01578   std::cout << {\cf22 "|- pTree leaf nodes num:     "} << this->pLeafNodeList.size()\par
01579             << std::endl;\par
01580   std::cout << {\cf22 "|- ProtoNode num:            "} << this->portNodeList.size()\par
01581             << std::endl;\par
01582   std::cout << {\cf22 "|- aTree leaf nodes num:     "} << this->aLeafNodeList.size()\par
01583             << std::endl;\par
01584   std::cout << {\cf22 "|- Average leaf node size:   "}\par
01585             << (double)rules / ({\cf18 double})(this->pLeafNodeList.size() +\par
01586                                         this->aLeafNodeList.size())\par
01587             << std::endl;\par
01588   {\cf19 if} (level > 1) \{\par
01589     {\cf18 double} equ_1 = 0;\par
01590     {\cf18 double} rang_1to100 = 0;\par
01591     {\cf18 double} lager_100 = 0;\par
01592     {\cf18 int} max_leaf = 0;\par
01593     {\cf19 for} ({\cf17 auto} leaf : this->pLeafNodeList) \{\par
01594       {\cf19 if} (leaf->Rule_5D.size() > max_leaf) max_leaf = leaf->Rule_5D.size();\par
01595       {\cf19 if} (leaf->Rule_5D.size() == 1)\par
01596         ++equ_1;\par
01597       {\cf19 else} {\cf19 if} (leaf->Rule_5D.size() < 100)\par
01598         ++rang_1to100;\par
01599       {\cf19 else}\par
01600         ++lager_100;\par
01601     \}\par
01602     {\cf19 for} ({\cf17 auto} leaf : this->aLeafNodeList) \{\par
01603       {\cf19 if} (leaf->Rule_5D.size() > max_leaf) max_leaf = leaf->Rule_5D.size();\par
01604       {\cf19 if} (leaf->Rule_5D.size() == 1)\par
01605         ++equ_1;\par
01606       {\cf19 else} {\cf19 if} (leaf->Rule_5D.size() < 100)\par
01607         ++rang_1to100;\par
01608       {\cf19 else}\par
01609         ++lager_100;\par
01610     \}\par
01611     std::cout << {\cf22 "|- Leaf node size->1:        "} << equ_1 << std::endl;\par
01612     std::cout << {\cf22 "|- Leaf node size->(1, 100]: "} << rang_1to100 << std::endl;\par
01613     std::cout << {\cf22 "|- Leaf node size->(100, +]: "} << lager_100 << std::endl;\par
01614     std::cout << {\cf22 "|- Max leaf node size:       "} << max_leaf << std::endl;\par
01615 \par
01616     {\cf19 if} (level > 2) \{\par
01617       FILE* fp = NULL;\par
01618       std::cout\par
01619           << {\cf22 "|- Write pTree inner node infomation to pInnerNode_info.txt...\\n"};\par
01620       fp = fopen({\cf22 "../info/pInnerNode_info.txt"}, {\cf22 "w"});\par
01621       fprintf(fp, {\cf22 "IpNode [ID LAYER FIELD TABLE_NUM CHILD_NUM]\\n\\n"});\par
01622       {\cf19 switch} (this->layerFields.size()) \{\par
01623         {\cf19 case} 3: \{\par
01624           {\cf19 for} ({\cf17 auto}& node : this->ipNodeList) \{\par
01625             IpNode_static* n = (IpNode_static*)node;\par
01626             {\cf18 int} c_num = 0;\par
01627             {\cf19 for} ({\cf18 int} i = 0; i < 257; ++i)\par
01628               {\cf19 if} (n->child[i].pointer != NULL) ++c_num;\par
01629             fprintf(fp, {\cf22 "%u\\t%u\\t%u\\t1\\t%d\\n"}, n->id, n->layer, n->field,\par
01630                     c_num);\par
01631           \}\par
01632           {\cf19 break};\par
01633         \}\par
01634         {\cf19 default}: \{\par
01635           {\cf19 for} ({\cf17 auto}& node : this->ipNodeList) \{\par
01636             IpNode* n = (IpNode*)node;\par
01637             {\cf18 int} c_num = 0;\par
01638             std::vector<IpTable>::iterator it = n->tableList.begin();\par
01639             {\cf19 for} (; it != n->tableList.end(); ++it) c_num += it->child.size();\par
01640             fprintf(fp, {\cf22 "%u\\t%u\\t%u\\t%llu\\t%d\\n"}, n->id, n->layer, n->field,\par
01641                     n->tableList.size(), c_num);\par
01642           \}\par
01643           {\cf19 break};\par
01644         \}\par
01645       \}\par
01646       fclose(fp);\par
01647 \par
01648       std::cout\par
01649           << {\cf22 "|- Write pTree leaf node infomation to pLeafNode_info.txt...\\n"};\par
01650       fp = fopen({\cf22 "../info/pLeafNode_info.txt"}, {\cf22 "w"});\par
01651       fprintf(\par
01652           fp,\par
01653           {\cf22 "Leaf Node [ID]\\n|- Rule_5D [PRI SIP DIP SPORT DPORT PROTOCOL]\\n"});\par
01654       {\cf19 for} ({\cf18 int} i = 0; i < this->pLeafNodeList.size(); ++i) \{\par
01655         fprintf(fp, {\cf22 "\\n%d\\t%llu\\n"}, i, this->pLeafNodeList[i]->Rule_5D.size());\par
01656         {\cf19 for} ({\cf17 auto} r : this->pLeafNodeList[i]->Rule_5D)\par
01657           fprintf(\par
01658               fp,\par
01659               {\cf22 "|- "}\par
01660               {\cf22 "%u\\t%u.%u.%u.%u/%u\\t\\t%u.%u.%u.%u/%u\\t\\t%u:%u\\t\\t%u:%u\\t\\t%u\\n"},\par
01661               r.pri, r.ipS[3], r.ipS[2], r.ipS[1], r.ipS[0], r.ipSMask,\par
01662               r.ipD[3], r.ipD[2], r.ipD[1], r.ipD[0], r.ipDMask, r.portS[0],\par
01663               r.portS[1], r.portD[0], r.portD[1], r.protocol[1]);\par
01664       \}\par
01665       fclose(fp);\par
01666 \par
01667       std::cout\par
01668           << {\cf22 "|- Write aTree inner node infomation to aInnerNode_info.txt...\\n"};\par
01669       fp = fopen({\cf22 "../info/aInnerNode_info.txt"}, {\cf22 "w"});\par
01670       fprintf(fp, {\cf22 "Protocol Node [ID TABLE_NUM CHILD_NUM]\\n\\n"});\par
01671       fprintf(fp, {\cf22 "0\\t1\\t%llu\\n\\n"}, this->aTree->child.size());\par
01672       fprintf(fp, {\cf22 "Port Node [ID TABLE_NUM CHILD_NUM]\\n\\n"});\par
01673       {\cf19 for} ({\cf17 auto} node : this->portNodeList) \{\par
01674         PortNode_static* n = (PortNode_static*)node;\par
01675         fprintf(fp, {\cf22 "%u\\t2\\t%llu\\n"}, n->id, n->child.size());\par
01676       \}\par
01677       fclose(fp);\par
01678 \par
01679       std::cout\par
01680           << {\cf22 "|- Write aTree leaf node infomation to aLeafNode_info.txt...\\n"};\par
01681       fp = fopen({\cf22 "../info/aLeafNode_info.txt"}, {\cf22 "w"});\par
01682       fprintf(fp,\par
01683               {\cf22 "Leaf Node [ID SIZE]\\n|- Rule_5D [PRI SIP DIP SPORT DPORT "}\par
01684               {\cf22 "PROTOCOL]\\n"});\par
01685       {\cf19 for} ({\cf18 int} i = 0; i < this->aLeafNodeList.size(); ++i) \{\par
01686         fprintf(fp, {\cf22 "\\n%d\\t%llu\\n"}, i, this->aLeafNodeList[i]->Rule_5D.size());\par
01687         {\cf19 for} ({\cf17 auto} r : this->aLeafNodeList[i]->Rule_5D)\par
01688           fprintf(\par
01689               fp,\par
01690               {\cf22 "|- "}\par
01691               {\cf22 "%u\\t%u.%u.%u.%u/%u\\t\\t%u.%u.%u.%u/%u\\t\\t%u:%u\\t\\t%u:%u\\t\\t%u\\n"},\par
01692               r.pri, r.ipS[3], r.ipS[2], r.ipS[1], r.ipS[0], r.ipSMask,\par
01693               r.ipD[3], r.ipD[2], r.ipD[1], r.ipD[0], r.ipDMask, r.portS[0],\par
01694               r.portS[1], r.portD[0], r.portD[1], r.protocol[1]);\par
01695       \}\par
01696       fclose(fp);\par
01697     \}\par
01698   \}\par
01699 \}\par
01700 \par
01701 {\cf18 size_t} PTtree::get_ipNode_mem(IpNode* node) \{\par
01702   {\cf18 size_t} sum = {\cf17 sizeof}(IpNode);\par
01703   {\cf19 for} (std::vector<IpTable>::iterator it = node->tableList.begin();\par
01704        it != node->tableList.end(); ++it) \{\par
01705     sum = sum + {\cf17 sizeof}(IpTable) + {\cf17 sizeof}({\cf18 short}) * it->table.size() +\par
01706           {\cf17 sizeof}(std::pair<uint32_t, void*>) * it->child.size();\par
01707   \}\par
01708   {\cf19 return} sum;\par
01709 \}\par
01710 \par
01711 {\cf18 size_t} PTtree::get_leafNode_mem(LeafNode* node) \{\par
01712   {\cf18 size_t} sum = {\cf17 sizeof}(LeafNode) + {\cf17 sizeof}(Rule_5D) * node->Rule_5D.size();\par
01713   {\cf19 return} sum;\par
01714 \}\par
01715 \par
01716 {\cf18 size_t} PTtree::get_static_mem(IpNode_static* node) \{\par
01717   {\cf18 size_t} sum = {\cf17 sizeof}(IpNode_static);\par
01718   {\cf19 if} (node->childType == 0) \{\par
01719     {\cf19 for} ({\cf18 int} i = 0; i < 257; ++i) \{\par
01720       {\cf19 if} (node->child[i].pointer != NULL)\par
01721         sum += get_static_mem((IpNode_static*)node->child[i].pointer);\par
01722     \}\par
01723   \} {\cf19 else} \{\par
01724     {\cf19 for} ({\cf18 int} i = 0; i < 257; ++i) \{\par
01725       {\cf19 if} (node->child[i].pointer != NULL)\par
01726         sum += get_leafNode_mem((LeafNode*)node->child[i].pointer);\par
01727     \}\par
01728   \}\par
01729   {\cf19 return} sum;\par
01730 \}\par
01731 \par
01732 {\cf18 size_t} PTtree::get_mem(IpNode* node) \{\par
01733   {\cf18 size_t} sum = get_ipNode_mem(node);\par
01734   {\cf19 if} (node->childType == 0) \{\par
01735     {\cf19 for} (std::vector<IpTable>::iterator it = node->tableList.begin();\par
01736          it != node->tableList.end(); ++it) \{\par
01737       {\cf19 for} ({\cf18 int} i = 0; i < it->child.size(); ++i) \{\par
01738         sum += get_mem((IpNode*)(it->child[i].second));\par
01739       \}\par
01740     \}\par
01741   \} {\cf19 else} \{\par
01742     {\cf19 for} (std::vector<IpTable>::iterator it = node->tableList.begin();\par
01743          it != node->tableList.end(); ++it) \{\par
01744       {\cf19 for} ({\cf18 int} i = 0; i < it->child.size(); ++i) \{\par
01745         sum += get_leafNode_mem((LeafNode*)(it->child[i].second));\par
01746       \}\par
01747     \}\par
01748   \}\par
01749   {\cf19 return} sum;\par
01750 \}\par
01751 \par
01752 {\cf18 size_t} PTtree::mem() \{\par
01753   {\cf18 size_t} sum = 0;\par
01754   {\cf19 if} (aTree != NULL) \{\par
01755     sum += {\cf17 sizeof}(ProtoNode) + {\cf17 sizeof}({\cf18 short}) * aTree->table.size() +\par
01756            {\cf17 sizeof}(std::pair<uint32_t, PortNode_static*>) * aTree->child.size();\par
01757     {\cf19 for} ({\cf17 auto}&& c : aTree->child) \{\par
01758       PortNode_static* pnode = (PortNode_static*)c.second;\par
01759       sum += {\cf17 sizeof}(PortNode_static) +\par
01760              {\cf17 sizeof}(std::pair<uint32_t, LeafNode*>) * pnode->child.size();\par
01761       {\cf19 for} ({\cf17 auto}&& leaf : pnode->child) \{\par
01762         sum += {\cf17 sizeof}(LeafNode) + leaf.second->Rule_5D.size() * {\cf17 sizeof}(Rule_5D);\par
01763       \}\par
01764     \}\par
01765   \}\par
01766   {\cf19 switch} (layerFields.size()) \{\par
01767     {\cf19 case} 3: \{\par
01768       {\cf19 return} sum + get_static_mem((IpNode_static*)pTree);\par
01769     \}\par
01770     {\cf19 default}:\par
01771       {\cf19 return} sum + get_mem((IpNode*)pTree);\par
01772   \}\par
01773 \}\par
01774 \par
01775 {\cf18 void} PTtree::analyse_ruleset(std::vector<Rule_5D>& v) \{\par
01776   {\cf18 char} ip_name[8][6] = \{{\cf22 "sip_1"}, {\cf22 "sip_2"}, {\cf22 "sip_3"}, {\cf22 "sip_4"},\par
01777                         {\cf22 "dip_1"}, {\cf22 "dip_2"}, {\cf22 "dip_3"}, {\cf22 "dip_4"}\};\par
01778   {\cf18 double} alpha[9];\par
01779   {\cf19 for} ({\cf18 int} i = 0; i < 9; ++i) alpha[i] = pow(2, i) / 511;\par
01780 \par
01781   FILE* fp = NULL;\par
01782   fp = fopen({\cf22 "../info/ruleset_analyse.txt"}, {\cf22 "w"});\par
01783   std::vector<std::vector<std::vector<int>>> counter;\par
01784   counter.resize(8);\par
01785   {\cf19 for} ({\cf18 int} i = 0; i < 8; ++i) \{\par
01786     counter[i].resize(9);\par
01787     {\cf19 for} ({\cf18 int} j = 0; j < 9; ++j) \{\par
01788       counter[i][j].resize(({\cf18 int})pow(2, j));\par
01789       {\cf19 for} ({\cf17 auto}& ele : counter[i][j]) ele = 0;\par
01790     \}\par
01791   \}\par
01792   {\cf19 for} ({\cf17 auto}& _r : v) \{\par
01793     {\cf18 int} k = 4;\par
01794     {\cf18 unsigned} {\cf18 int} mask = _r.ipSMask;\par
01795     {\cf19 for} ({\cf18 int} j = 0; j < 4; j++) \{\par
01796       {\cf18 unsigned} {\cf18 int} value = _r.ipS[--k];\par
01797       {\cf18 int} _m = maskHash[mask][j];\par
01798       value = value >> (8 - _m);\par
01799       ++counter[j][_m][value];\par
01800     \}\par
01801     k = 4;\par
01802     mask = _r.ipDMask;\par
01803     {\cf19 for} ({\cf18 int} j = 4; j < 8; j++) \{\par
01804       {\cf18 unsigned} {\cf18 int} value = _r.ipD[--k];\par
01805       {\cf18 int} _m = maskHash[mask][j - 4];\par
01806       value = value >> (8 - _m);\par
01807       ++counter[j][_m][value];\par
01808     \}\par
01809   \}\par
01810   std::vector<std::vector<double>> gini(8, std::vector<double>(9, 0));\par
01811   {\cf19 for} ({\cf18 int} i = 0; i < 8; ++i) \{\par
01812     {\cf19 for} ({\cf18 int} j = 0; j < 9; ++j) \{\par
01813       {\cf18 int} c_size = counter[i][j].size();\par
01814       {\cf18 double} _y = 0;\par
01815       std::vector<double> _yy(c_size + 1, 0);\par
01816       {\cf19 for} ({\cf18 int} k = 0; k < c_size; ++k) \{\par
01817         _y += counter[i][j][k];\par
01818       \}\par
01819       {\cf19 if} (_y != 0) \{\par
01820         {\cf18 double} tmp = 0;\par
01821         std::vector<int> tmp_y(counter[i][j]);\par
01822         sort(tmp_y.begin(), tmp_y.end());\par
01823         {\cf19 for} ({\cf18 int} k = 0; k < c_size; ++k) \{\par
01824           tmp += tmp_y[k];\par
01825           _yy[k + 1] = tmp / _y;\par
01826           {\cf20 // printf("%lf ", _yy[k + 1]);}\par
01827         \}\par
01828         {\cf20 // printf("\\n");}\par
01829         {\cf18 double} sum = 0, a = 0;\par
01830         {\cf19 for} ({\cf18 int} k = 0; k < c_size; ++k) \{\par
01831           a = (_yy[k] + _yy[k + 1]) / 2.0 / c_size;\par
01832           sum += a;\par
01833         \}\par
01834         gini[i][j] = (0.5 - sum) / 0.5;\par
01835       \}\par
01836     \}\par
01837     gini[i][0] = 1;\par
01838   \}\par
01839   {\cf19 for} ({\cf18 int} i = 0; i < 8; ++i) \{\par
01840     {\cf18 double} _g = 0;\par
01841     fprintf(fp, {\cf22 "%s\\n"}, ip_name[i]);\par
01842     {\cf19 for} ({\cf18 int} j = 0; j < 9; ++j) \{\par
01843       fprintf(fp, {\cf22 "\\tmask=%d"}, j);\par
01844       {\cf19 for} ({\cf17 auto} ele : counter[i][j]) \{\par
01845         fprintf(fp, {\cf22 " %d"}, ele);\par
01846       \}\par
01847       fprintf(fp, {\cf22 " gini=%lf\\n"}, gini[i][j]);\par
01848       _g += (alpha[j] * gini[i][j]);\par
01849     \}\par
01850     fprintf(fp, {\cf22 "total_gini=%lf\\n"}, _g);\par
01851   \}\par
01852   fclose(fp);\par
01853 \}\par
01854 \par
01855 {\cf18 int} check_correct(Rule_5D& a, Packet_5D& b) \{\par
01856   {\cf19 if} (a.protocol[0] != 0 && (uint32_t)a.protocol[1] != b.protocol) {\cf19 return} 0;\par
01857   {\cf18 int} mask = 32 - (uint32_t)a.ipSMask;\par
01858   uint32_t sip, dip;\par
01859   memcpy(&sip, a.ipS, 4);\par
01860   memcpy(&dip, b.ipS, 4);\par
01861   {\cf19 if} (mask != 32 && (sip >> mask) != (dip >> mask)) {\cf19 return} 0;\par
01862   mask = 32 - (uint32_t)a.ipDMask;\par
01863   memcpy(&sip, a.ipD, 4);\par
01864   memcpy(&dip, b.ipD, 4);\par
01865   {\cf19 if} (mask != 32 && (sip >> mask) != (dip >> mask)) {\cf19 return} 0;\par
01866   {\cf19 if} (b.portS < a.portS[0] || b.portS > a.portS[1]) {\cf19 return} 0;\par
01867   {\cf19 if} (b.portD < a.portD[0] || b.portD > a.portD[1]) {\cf19 return} 0;\par
01868   {\cf19 return} 1;\par
01869 \}\par
01870 \par
01871 {\cf18 int} simple_search(std::vector<Rule_5D>& rules, Packet_5D& b) \{\par
01872   {\cf19 for} ({\cf17 auto}&& a : rules) \{\par
01873     {\cf19 if} (a.protocol[0] != 0 && (uint32_t)a.protocol[1] != b.protocol) {\cf19 continue};\par
01874     {\cf18 int} mask = 32 - (uint32_t)a.ipSMask;\par
01875     uint32_t sip, dip;\par
01876     memcpy(&sip, a.ipS, 4);\par
01877     memcpy(&dip, b.ipS, 4);\par
01878     {\cf19 if} (mask != 32 && (sip >> mask) != (dip >> mask)) {\cf19 continue};\par
01879     mask = 32 - (uint32_t)a.ipDMask;\par
01880     memcpy(&sip, a.ipD, 4);\par
01881     memcpy(&dip, b.ipD, 4);\par
01882     {\cf19 if} (mask != 32 && (sip >> mask) != (dip >> mask)) {\cf19 continue};\par
01883     {\cf19 if} (b.portS < a.portS[0] || b.portS > a.portS[1]) {\cf19 continue};\par
01884     {\cf19 if} (b.portD < a.portD[0] || b.portD > a.portD[1]) {\cf19 continue};\par
01885     {\cf19 return} a.pri;\par
01886   \}\par
01887   {\cf19 return} -1;\par
01888 \}\par
01889 \par
01890 {\cf18 void} setmaskHash() \{\par
01891   {\cf19 for} ({\cf18 int} i = 0; i < 33; ++i) \{\par
01892     {\cf18 int} j = 0;\par
01893     {\cf19 for} (; j < i / 8; ++j) maskHash[i][j] = 8;\par
01894     {\cf19 if} (j < 4) \{\par
01895       maskHash[i][j] = i % 8;\par
01896       {\cf19 for} (++j; j < 4; ++j) maskHash[i][j] = 0;\par
01897     \}\par
01898   \}\par
01899 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
METHOD/PTtree.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v METHOD/PTtree.hpp}
{\xe \v METHOD/PTtree.hpp}
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../OBJECT/basis.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for PTtree.hpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "_p_ttree_8hpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "_p_ttree_8hpp__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b IpTable}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b IpNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b IpChild}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b IpNode_static}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b LeafNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b PortNode_static}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ProtoNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ACL_LOG}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b PTtree}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b search_config} (std::vector< std::vector< int > > v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b check_correct} ({\b Rule_5D} &a, {\b Packet_5D} &b)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b simple_search} (std::vector< {\b Rule_5D} > &rules, {\b Packet_5D} &b)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setmaskHash} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b maskHash} [33][4]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v check_correct\:PTtree.hpp}
{\xe \v PTtree.hpp\:check_correct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int check_correct ({\b Rule_5D} &  {\i a}, {\b Packet_5D} &  {\i b})}}
\par
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1855} of file {\b PTtree.cpp}.}\par
}
{\xe \v search_config\:PTtree.hpp}
{\xe \v PTtree.hpp\:search_config}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int search_config (std::vector< std::vector< int > >  {\i v})}}
\par
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v setmaskHash\:PTtree.hpp}
{\xe \v PTtree.hpp\:setmaskHash}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setmaskHash ()}}
\par
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1890} of file {\b PTtree.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "_p_ttree_8hpp_abbad462dd1fbeaad29449e0e78e118ce_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v simple_search\:PTtree.hpp}
{\xe \v PTtree.hpp\:simple_search}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int simple_search (std::vector< {\b Rule_5D} > &  {\i rules}, {\b Packet_5D} &  {\i b})}}
\par
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1871} of file {\b PTtree.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v maskHash\:PTtree.hpp}
{\xe \v PTtree.hpp\:maskHash}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t maskHash[33][4]{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3} of file {\b PTtree.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
PTtree.hpp\par \pard\plain 
{\tc\tcl2 \v METHOD/PTtree.hpp}
{\xe \v METHOD/PTtree.hpp}
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef _PTTREE_HPP_}\par
00002 {\cf21 #define _PTTREE_HPP_}\par
00003 {\cf21 #include "../OBJECT/basis.hpp"}\par
00004 {\cf17 extern} uint8_t maskHash[33][4];\par
00005 \par
00006 {\cf17 struct }IpTable \{\par
00007   uint32_t pri;\par
00008   uint32_t mask;\par
00009   std::vector<short> table;\par
00010   std::vector<std::pair<uint32_t, void*>> child;  {\cf20 // first: pri second: pointer}\par
00011   IpTable(uint32_t n) : table(1 << n, -1), pri(0), mask(n) \{\}\par
00012 \};\par
00013 \par
00014 {\cf17 struct }IpNode \{\par
00015   uint32_t id;\par
00016   uint16_t layer;\par
00017   uint8_t field;                   {\cf20 // 0-3: sip 1-4; 4-7: dip 1-4}\par
00018   {\cf18 bool} childType;                  {\cf20 // 0: innernode; 1: leafnode}\par
00019   std::vector<IpTable> tableList;  {\cf20 // first: pri second: table}\par
00020   IpNode(uint8_t _field, {\cf18 bool} _cType, uint16_t _layer, uint32_t _id)\par
00021       : field(_field), childType(_cType), layer(_layer), id(_id) \{\}\par
00022 \};\par
00023 \par
00024 {\cf17 struct }IpChild \{\par
00025   {\cf18 void}* pointer;\par
00026   {\cf18 int} pri;\par
00027   IpChild() : pointer(NULL) \{\}\par
00028 \};\par
00029 {\cf17 struct }IpNode_static \{\par
00030   uint32_t id;\par
00031   uint16_t layer;\par
00032   uint8_t field;   {\cf20 // 0-3: sip 1-4; 4-7: dip 1-4}\par
00033   {\cf18 bool} childType;  {\cf20 // 0: innernode; 1: leafnode}\par
00034   IpChild child[257];\par
00035   IpNode_static(uint8_t _field, {\cf18 bool} _cType, uint16_t _layer, uint32_t _id)\par
00036       : field(_field), childType(_cType), layer(_layer), id(_id) \{\}\par
00037 \};\par
00038 {\cf17 struct }LeafNode \{\par
00039   std::vector<Rule_5D> Rule_5D;\par
00040 \};\par
00041 {\cf17 struct }PortNode_static \{\par
00042   uint32_t id;\par
00043   {\cf18 short} table[32769];\par
00044   std::vector<std::pair<uint32_t, LeafNode*>> child;\par
00045   PortNode_static(uint32_t _id) : id(_id) \{\par
00046     {\cf19 for} ({\cf18 int} i = 0; i < 32769; ++i) table[i] = -1;\par
00047   \}\par
00048 \};\par
00049 {\cf17 struct }ProtoNode \{\par
00050   std::vector<short> table;\par
00051   std::vector<std::pair<uint32_t, void*>> child;\par
00052   ProtoNode() : table(256, -1) \{\}\par
00053 \};\par
00054 \par
00055 {\cf17 struct }ACL_LOG \{\par
00056   {\cf18 int} rules;\par
00057   {\cf18 int} tables;\par
00058   {\cf18 int} innerNodes;\par
00059   {\cf18 int} leafNodes;\par
00060   std::vector<void*> ipNodeList;\par
00061   std::vector<LeafNode*> pLeafNodeList;\par
00062   std::vector<void*> portNodeList;\par
00063   std::vector<LeafNode*> aLeafNodeList;\par
00064   ACL_LOG() : rules(0), tables(0), innerNodes(0), leafNodes(0) \{\}\par
00065 \};\par
00066 \par
00067 {\cf17 class }PTtree \{\par
00068  {\cf17 private}:\par
00069   std::vector<uint8_t> layerFields;\par
00070   {\cf18 int} portField, portStep;\par
00071 \par
00072  {\cf17 public}:\par
00073   {\cf18 void}* pTree;\par
00074   ProtoNode* aTree;\par
00075   {\cf18 int} totalNodes;\par
00076   std::vector<void*> ipNodeList;\par
00077   std::vector<void*> portNodeList;\par
00078   std::vector<LeafNode*> pLeafNodeList;\par
00079   std::vector<LeafNode*> aLeafNodeList;\par
00080 \par
00081   PTtree(std::vector<uint8_t>& v, {\cf18 int} _portField);\par
00082   PTtree(std::vector<uint8_t>& v, {\cf18 int} _portField, {\cf18 int} _portStep);\par
00083   ~PTtree();\par
00084 \par
00085   {\cf18 void} freeStaticNode(IpNode_static* node);\par
00086   {\cf18 void} freeNode(IpNode* node);\par
00087 \par
00088   {\cf18 void} insert(Rule_5D& r);\par
00089   {\cf18 void} insert_up(Rule_5D& r);\par
00090   {\cf18 bool} remove(Rule_5D& r);\par
00091 \par
00092   {\cf18 int} search(Packet_5D& p);\par
00093   {\cf18 int} search_with_log(Packet_5D& p, ACL_LOG& log);\par
00094 \par
00095   {\cf18 bool} update(std::vector<Rule_5D>& rules, {\cf18 int} num, {\cf17 struct} timespec& t1,\par
00096               {\cf17 struct} timespec& t2);\par
00097 \par
00098   {\cf18 void} print_node_info({\cf18 int} level, {\cf18 int} rules);\par
00099 \par
00100   {\cf18 size_t} get_ipNode_mem(IpNode* node);\par
00101   {\cf18 size_t} get_leafNode_mem(LeafNode* node);\par
00102   {\cf18 size_t} get_static_mem(IpNode_static* node);\par
00103   {\cf18 size_t} get_mem(IpNode* node);\par
00104   {\cf18 size_t} mem();\par
00105 \par
00106   {\cf18 void} analyse_ruleset(std::vector<Rule_5D>& v);\par
00107 \};\par
00108 \par
00109 {\cf18 int} search_config(std::vector<std::vector<int>> v);\par
00110 {\cf18 int} check_correct(Rule_5D& a, Packet_5D& b);\par
00111 {\cf18 int} simple_search(std::vector<Rule_5D>& rules, Packet_5D& b);\par
00112 {\cf18 void} setmaskHash();\par
00113 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
OBJECT/basis.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v OBJECT/basis.cpp}
{\xe \v OBJECT/basis.cpp}
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "basis.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for basis.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "basis_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
basis.cpp\par \pard\plain 
{\tc\tcl2 \v OBJECT/basis.cpp}
{\xe \v OBJECT/basis.cpp}
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * @title: basis.cpp}\par
00003 {\cf20  * @author: Jia-Chang, Chang}\par
00004 {\cf20  * @date: 2023-12-09}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #include "basis.hpp"}\par
00008 \par
00009 {\cf18 void} Rule_5D::ip_merge() \{\par
00010   this->ipS32 = ((uint32_t)this->ipS[0] << 24) |\par
00011                 ((uint32_t)this->ipS[1] << 16) | ((uint32_t)this->ipS[2] << 8) |\par
00012                 ((uint32_t)this->ipS[3]);\par
00013   this->ipD32 = ((uint32_t)this->ipD[0] << 24) |\par
00014                 ((uint32_t)this->ipD[1] << 16) | ((uint32_t)this->ipD[2] << 8) |\par
00015                 ((uint32_t)this->ipD[3]);\par
00016 \};\par
00017 {\cf18 void} Packet_5D::ip_merge() \{\par
00018   this->ipS32 = ((uint32_t)this->ipS[0] << 24) |\par
00019                 ((uint32_t)this->ipS[1] << 16) | ((uint32_t)this->ipS[2] << 8) |\par
00020                 ((uint32_t)this->ipS[3]);\par
00021   this->ipD32 = ((uint32_t)this->ipD[0] << 24) |\par
00022                 ((uint32_t)this->ipD[1] << 16) | ((uint32_t)this->ipD[2] << 8) |\par
00023                 ((uint32_t)this->ipD[3]);\par
00024 \};\par
00025 \par
00026 {\cf18 void} Timer::timeReset() \{ m_beg = Clock::now(); \};\par
00027 \par
00028 {\cf18 double} Timer::elapsed_s(){\cf17  const }\{\par
00029   {\cf19 return} std::chrono::duration_cast<Second>(Clock::now() - m_beg).count();\par
00030 \};\par
00031 {\cf18 unsigned} {\cf18 long} {\cf18 long} Timer::elapsed_ns(){\cf17  const }\{\par
00032   {\cf19 return} std::chrono::milliseconds((Clock::now() - m_beg).count()).count();\par
00033 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
OBJECT/basis.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v OBJECT/basis.hpp}
{\xe \v OBJECT/basis.hpp}
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <getopt.h>}\par
{\f2 #include <math.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <algorithm>}\par
{\f2 #include <chrono>}\par
{\f2 #include <fstream>}\par
{\f2 #include <iostream>}\par
{\f2 #include <random>}\par
{\f2 #include <vector>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for basis.hpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "basis_8hpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "basis_8hpp__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Rule_5D}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Packet_5D}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Timer}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ACL_rules}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b GetCPUCycle} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v GetCPUCycle\:basis.hpp}
{\xe \v basis.hpp\:GetCPUCycle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t GetCPUCycle (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 84} of file {\b basis.hpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
basis.hpp\par \pard\plain 
{\tc\tcl2 \v OBJECT/basis.hpp}
{\xe \v OBJECT/basis.hpp}
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * @title: basis.hpp}\par
00003 {\cf20  * @author: Jia-Chang, Chang}\par
00004 {\cf20  * @date: 2023-12-09}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #ifndef __OBJECT_BASIS_HPP__}\par
00008 {\cf21 #define __OBJECT_BASIS_HPP__}\par
00009 {\cf21 #include <getopt.h>}\par
00010 {\cf21 #include <math.h>}\par
00011 {\cf21 #include <stdlib.h>}\par
00012 {\cf21 #include <unistd.h>}\par
00013 \par
00014 {\cf21 #include <algorithm>}\par
00015 {\cf21 #include <chrono>}\par
00016 {\cf21 #include <fstream>}\par
00017 {\cf21 #include <iostream>}\par
00018 {\cf21 #include <random>}\par
00019 {\cf21 #include <vector>}\par
00020 \par
00021 {\cf17 class }Rule_5D \{\par
00022  {\cf17 public}:\par
00023   {\cf18 unsigned} {\cf18 int} pri = 0;\par
00024   {\cf17 union }\{\par
00025     uint8_t ipS[4];\par
00026     uint32_t ipS32;\par
00027   \};\par
00028   {\cf17 union }\{\par
00029     uint8_t ipD[4];\par
00030     uint32_t ipD32;\par
00031   \};\par
00032   uint16_t portS[2];\par
00033   uint16_t portD[2];\par
00034   uint8_t ipSMask;\par
00035   uint8_t ipDMask;\par
00036   uint8_t protocol[2];\par
00037 \par
00038   {\cf18 void} ip_merge();\par
00039 \};\par
00040 \par
00041 {\cf17 class }Packet_5D \{\par
00042  {\cf17 public}:\par
00043   uint16_t portS;\par
00044   uint16_t portD;\par
00045   {\cf17 union }\{\par
00046     uint8_t ipS[4];\par
00047     uint32_t ipS32;\par
00048   \};\par
00049   uint8_t protocol;\par
00050   {\cf17 union }\{\par
00051     uint8_t ipD[4];\par
00052     uint32_t ipD32;\par
00053   \};\par
00054 \par
00055   {\cf18 void} ip_merge();\par
00056 \};\par
00057 \par
00058 {\cf17 class }Timer \{\par
00059  {\cf17 private}:\par
00060   {\cf20 // Type aliases to make accessing nested type easier}\par
00061   {\cf17 using }Clock = std::chrono::steady_clock;\par
00062   {\cf17 using }Second = std::chrono::duration<double, std::ratio<1> >;\par
00063 \par
00064   std::chrono::time_point<Clock> m_beg\{Clock::now()\};\par
00065 \par
00066  {\cf17 public}:\par
00067   {\cf18 void} timeReset();\par
00068   {\cf18 double} elapsed_s() {\cf17 const};\par
00069   {\cf18 unsigned} {\cf18 long} {\cf18 long} elapsed_ns() {\cf17 const};\par
00070 \};\par
00071 \par
00072 {\cf20 // https://www.learncpp.com/cpp-tutorial/timing-your-code/}\par
00073 {\cf20 // Timer using ex:}\par
00074 {\cf20 // int main()}\par
00075 {\cf20 // \{}\par
00076 {\cf20 //     std::array<int, g_arrayElements> array;}\par
00077 {\cf20 //     std::iota(array.rbegin(), array.rend(), 1);}\par
00078 {\cf20 //     Timer t;}\par
00079 {\cf20 //     sortArray(array);}\par
00080 {\cf20 //     std::cout << "Time taken: " << t.elapsed_s() << " seconds\\n";}\par
00081 {\cf20 //     return 0;}\par
00082 {\cf20 // \}}\par
00083 \par
00084 uint64_t {\cf17 inline} GetCPUCycle() \{\par
00085 {\cf21 #ifdef __x86_64__}\par
00086   {\cf18 unsigned} {\cf18 int} lo, hi;\par
00087   {\cf20 // __asm__ \'E6\'8C\'87\'E7\'A4\'BA\'E7\'B7\'A8\'E8\'AD\'AF\'E5\'99\'A8\'E5\'9C\'A8\'E6\'AD\'A4\'E6\'8F\'92\'E5\'85\'A5\'E5\'BD\'99\'E7\'B7\'A8\'E8\'AA\'9E\'E5\'8F\'A5, \'E8\'81\'B2\'E6\'98\'8E\'E4\'B8\'80\'E5\'80\'8B\'E5\'85\'A7\'E8\'81\'AF\'E5\'BD\'99\'E7\'B7\'A8\'E8\'A1\'A8\'E9\'81\'94\'E5\'BC\'8F}\par
00088   {\cf20 // __volatile__ \'E5\'9A\'B4\'E7\'A6\'81\'E5\'B0\'87\'E6\'AD\'A4\'E8\'99\'95\'E7\'9A\'84\'E5\'BD\'99\'E7\'B7\'A8\'E8\'AA\'9E\'E5\'8F\'A5\'E8\'88\'87\'E5\'85\'B6\'E5\'AE\'83\'E7\'9A\'84\'E8\'AA\'9E\'E5\'8F\'A5\'E9\'87\'8D\'E7\'B5\'84\'E5\'90\'88\'E5\'84\'AA\'E5\'8C\'96}\par
00089   {\cf20 // memory}\par
00090   {\cf20 // gcc\'E7\'B7\'A8\'E8\'AD\'AF\'E5\'99\'A8\'E5\'81\'87\'E8\'A8\'ADRAM\'E6\'89\'80\'E6\'9C\'89\'E8\'A8\'98\'E6\'86\'B6\'E9\'AB\'94\'E5\'96\'AE\'E5\'85\'83\'E5\'9D\'87\'E8\'A2\'AB\'E5\'BD\'99\'E7\'B7\'A8\'E6\'8C\'87\'E4\'BB\'A4\'E4\'BF\'AE\'E6\'94\'B9\'EF\'BC\'8C\'E9\'80\'99\'E6\'A8\'A3cpu\'E4\'B8\'AD\'E7\'9A\'84registers\'E5\'92\'8Ccache\'E4\'B8\'AD\'E5\'B7\'B2\'E5\'BF\'AB\'E5\'8F\'96\'E7\'9A\'84\'E8\'A8\'98\'E6\'86\'B6\'E9\'AB\'94\'E5\'96\'AE\'E5\'85\'83\'E4\'B8\'AD\'E7\'9A\'84\'E6\'95\'B8\'E6\'93\'9A\'E5\'B0\'87\'E4\'BD\'9C\'E5\'BB\'A2,}\par
00091   {\cf20 // cpu\'E5\'B0\'87\'E4\'B8\'8D\'E5\'BE\'97\'E4\'B8\'8D\'E5\'9C\'A8\'E9\'9C\'80\'E8\'A6\'81\'E7\'9A\'84\'E6\'99\'82\'E5\'80\'99\'E9\'87\'8D\'E6\'96\'B0\'E8\'AE\'80\'E5\'8F\'96\'E8\'A8\'98\'E6\'86\'B6\'E9\'AB\'94\'E4\'B8\'AD\'E7\'9A\'84\'E6\'95\'B8\'E6\'93\'9A lfence}\par
00092   {\cf20 // \'E5\'9C\'A8lfence\'E6\'8C\'87\'E4\'BB\'A4\'E5\'89\'8D\'E7\'9A\'84\'E8\'AE\'80\'E6\'93\'8D\'E4\'BD\'9C\'E7\'95\'B6\'E5\'BF\'85\'E9\'A0\'88\'E5\'9C\'A8lfence\'E6\'8C\'87\'E4\'BB\'A4\'E5\'90\'8E\'E7\'9A\'84\'E8\'AE\'80\'E6\'93\'8D\'E4\'BD\'9C\'E5\'89\'8D\'E5\'AE\'8C\'E6\'88\'90}\par
00093   __asm__ __volatile__({\cf22 "lfence"} : : : {\cf22 "memory"});  {\cf20 // \'E8\'A8\'98\'E6\'86\'B6\'E9\'AB\'94\'E5\'B1\'8F\'E9\'9A\'9C}\par
00094   {\cf20 // rdtsc: ReaD TimeStamp Counter, it reads a 64-bit counter that counts up at}\par
00095   {\cf20 // every clock cycle of your processor.}\par
00096   __asm__ __volatile__({\cf22 "rdtsc"} : {\cf22 "=a"}(lo), {\cf22 "=d"}(hi));\par
00097   {\cf19 return} ((uint64_t)hi << 32) | lo;\par
00098 {\cf21 #elif __aarch64__}\par
00099   uint64_t v = 0;\par
00100   {\cf20 //  Instruction Synchronization Barrier (ISB) flushes the pipeline in the}\par
00101   {\cf20 //  processor, so that all instructions following the ISB are fetched from}\par
00102   {\cf20 //  cache or memory, after the ISB has been completed.}\par
00103   {\cf17 asm} {\cf17 volatile}({\cf22 "isb"} : : : {\cf22 "memory"});\par
00104   {\cf17 asm} {\cf17 volatile}(\par
00105       {\cf22 "mrs %0, cntvct_el0"}\par
00106       : {\cf22 "=r"}(v));  {\cf20 // \'E8\'99\'9B\'E6\'93\'AC\'E8\'A8\'88\'E6\'99\'82\'E5\'99\'A8\'E8\'A8\'88\'E6\'95\'B8\'E6\'9A\'AB\'E5\'AD\'98\'E5\'99\'A8 CNTPCT_EL0\'E7\'89\'A9\'E7\'90\'86\'E8\'A8\'88\'E6\'99\'82\'E5\'99\'A8\'E8\'A8\'88\'E6\'95\'B8\'E6\'9A\'AB\'E5\'AD\'98\'E5\'99\'A8}\par
00107   {\cf20 // asm volatile("mrs %0, pmccntr_el0" : "=r" (v)); // Performance Monitors}\par
00108   {\cf20 // Cycle Count Register}\par
00109   {\cf19 return} v;\par
00110 {\cf21 #else}\par
00111   printf({\cf22 "unknown arch\\n"});\par
00112   {\cf19 return} 0;\par
00113 {\cf21 #endif}\par
00114 \}\par
00115 \par
00116 {\cf17 struct }ACL_rules \{\par
00117   {\cf18 int} size;\par
00118   {\cf18 int} capacity;\par
00119   Rule_5D* list;\par
00120   ACL_rules() : size(0), capacity(0), list(nullptr) \{\}\par
00121 \};\par
00122 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
OBJECT/tuple_v1.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v OBJECT/tuple_v1.hpp}
{\xe \v OBJECT/tuple_v1.hpp}
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
tuple_v1.hpp\par \pard\plain 
{\tc\tcl2 \v OBJECT/tuple_v1.hpp}
{\xe \v OBJECT/tuple_v1.hpp}
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef __OBJECT_TUPLE_V1_HPP__}\par
00002 {\cf21 #define __OBJECT_TUPLE_V1_HPP__}\par
00003 \par
00004 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
PT-tree_main/ptMain.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v PT-tree_main/ptMain.cpp}
{\xe \v PT-tree_main/ptMain.cpp}
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../IO/IO_TEST/inputFile_test.hpp"}\par
{\f2 #include "../IO/input_v1.hpp"}\par
{\f2 #include "../IO/output_v1.hpp"}\par
{\f2 #include "../METHOD/PTtree.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for ptMain.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "pt_main_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b get_nano_time} (struct timespec *a, struct timespec *b)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b get_milli_time} (struct timespec *a, struct timespec *b)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} (int argc, char *argv[])\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v get_milli_time\:ptMain.cpp}
{\xe \v ptMain.cpp\:get_milli_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double get_milli_time (struct timespec *  {\i a}, struct timespec *  {\i b})}}
\par
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b ptMain.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "pt_main_8cpp_a23ab563a1bdbabb818399e30cae77d83_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v get_nano_time\:ptMain.cpp}
{\xe \v ptMain.cpp\:get_nano_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double get_nano_time (struct timespec *  {\i a}, struct timespec *  {\i b})}}
\par
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b ptMain.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "pt_main_8cpp_afd2dbef17fe36062a316b82bc416f12b_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v main\:ptMain.cpp}
{\xe \v ptMain.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main (int  {\i argc}, char *  {\i argv}[])}}
\par
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b ptMain.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "pt_main_8cpp_a0ddf1224851353fc92bfbff6f499fa97_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ptMain.cpp\par \pard\plain 
{\tc\tcl2 \v PT-tree_main/ptMain.cpp}
{\xe \v PT-tree_main/ptMain.cpp}
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20 PT-tree origin:}\par
00003 {\cf20 lavline}\par
00004 {\cf20 https://github.com/lavline/PT-Tree}\par
00005 {\cf20 PT-Tree: A Cascading Prefix Tuple Tree for Packet Classification in Dynamic}\par
00006 {\cf20 Scenarios https://ieeexplore.ieee.org/document/10171802}\par
00007 {\cf20 }\par
00008 {\cf20  * @title: main.cpp}\par
00009 {\cf20  * @author: Jia-Chang, Chang}\par
00010 {\cf20  * @date: 2023-12-08}\par
00011 {\cf20  */}\par
00012 {\cf21 #include "../IO/IO_TEST/inputFile_test.hpp"}\par
00013 {\cf21 #include "../IO/input_v1.hpp"}\par
00014 {\cf21 #include "../IO/output_v1.hpp"}\par
00015 {\cf21 #include "../METHOD/PTtree.hpp"}\par
00016 {\cf17 using }std::cerr;\par
00017 {\cf17 using }std::cin;\par
00018 {\cf17 using }std::cout;\par
00019 {\cf17 using }std::vector;\par
00020 \par
00021 {\cf18 double} get_nano_time({\cf17 struct} timespec* a, {\cf17 struct} timespec* b) \{\par
00022   {\cf19 return} (b->tv_sec - a->tv_sec) * 1000000000 + b->tv_nsec - a->tv_nsec;\par
00023 \}\par
00024 {\cf18 double} get_milli_time({\cf17 struct} timespec* a, {\cf17 struct} timespec* b) \{\par
00025   {\cf19 return} (b->tv_sec - a->tv_sec) * 1000 +\par
00026          (double)(b->tv_nsec - a->tv_nsec) / 1000000.0;\par
00027 \}\par
00028 {\cf18 int} main({\cf18 int} argc, {\cf18 char}* argv[]) \{\par
00029   vector<Rule_5D> rule5V;\par
00030   vector<Packet_5D> packet5V;\par
00031   InputFile5D InputFile_5D;\par
00032   InputFile5D_test InputFile5D_test;\par
00033   OutputFile5D OutputFile_5D;\par
00034 \par
00035   {\cf18 bool} enable_log = {\cf17 false};\par
00036   {\cf18 bool} enable_update = {\cf17 false};\par
00037   {\cf18 int} log_level = 1;  {\cf20 // \{1,2,3\}}\par
00038   vector<uint8_t> set_field;\par
00039   {\cf18 int} set_port = 1;\par
00040   std::string ipFieldName[8] = \{{\cf22 "Sip1"}, {\cf22 "Sip2"}, {\cf22 "Sip3"}, {\cf22 "Sip4"},\par
00041                                 {\cf22 "Dip1"}, {\cf22 "Dip2"}, {\cf22 "Dip3"}, {\cf22 "Dip4"}\};\par
00042   vector<Rule_5D> rules;\par
00043   vector<Packet_5D> packets;\par
00044   {\cf17 struct }timespec t1, t2;\par
00045 \par
00046   {\cf17 static} {\cf17 struct }option long_options[] = \{\par
00047       \{{\cf22 "ruleset"}, required_argument, NULL, {\cf23 'r'}\},\par
00048       \{{\cf22 "trace"}, required_argument, NULL, {\cf23 'p'}\},\par
00049       \{{\cf22 "unit_test"}, no_argument, NULL, {\cf23 't'}\},\par
00050       \{{\cf22 "merge"}, no_argument, NULL, {\cf23 'm'}\},\par
00051       \{{\cf22 "merge_test"}, no_argument, NULL, {\cf23 'n'}\},\par
00052       \{{\cf22 "fields"}, 1, NULL, {\cf23 'f'}\},\par
00053       \{{\cf22 "log"}, 1, NULL, {\cf23 'l'}\},\par
00054       \{{\cf22 "update"}, 0, NULL, {\cf23 'u'}\},\par
00055       \{{\cf22 "help"}, no_argument, NULL, {\cf23 'h'}\},\par
00056       \{0, 0, 0, 0\}  {\cf20 // End of options marker}\par
00057   \};\par
00058   {\cf18 int} option;\par
00059   {\cf19 while} ((option = getopt_long(argc, argv, {\cf22 "r:p:t::m::n::h::f:l:u::"},\par
00060                                long_options, {\cf17 nullptr})) != -1) \{\par
00061     {\cf19 switch} (option) \{\par
00062       {\cf19 case} {\cf23 'r'}:\par
00063         cout << {\cf22 "Read ruleset:  "} << optarg << {\cf22 "\\n"};\par
00064         OutputFile_5D.timer.timeReset();\par
00065         {\cf19 if} (InputFile_5D.inputRule5D(rules, optarg)) \{\par
00066           cout << {\cf22 "Read ruleset ERROR!!"}\par
00067                << {\cf22 "\\n"};\par
00068           {\cf19 return} -1;\par
00069         \}\par
00070         cout << {\cf22 "Read ruleset time(ns): "} << OutputFile_5D.timer.elapsed_ns()\par
00071              << {\cf22 "\\n"};\par
00072         cout << {\cf22 "Read ruleset time(s): "} << OutputFile_5D.timer.elapsed_s()\par
00073              << {\cf22 "\\n"};\par
00074         {\cf19 break};\par
00075       {\cf19 case} {\cf23 'p'}:\par
00076         cout << {\cf22 "Rread trace: "} << optarg << {\cf22 "\\n"};\par
00077         OutputFile_5D.timer.timeReset();\par
00078         {\cf19 if} (InputFile_5D.inputPacket5D(packets, optarg)) \{\par
00079           cout << {\cf22 "Read trace ERROR!!"}\par
00080                << {\cf22 "\\n"};\par
00081           {\cf19 return} -1;\par
00082         \}\par
00083         cout << {\cf22 "Read trace time(ns): "} << OutputFile_5D.timer.elapsed_ns()\par
00084              << {\cf22 "\\n"};\par
00085         cout << {\cf22 "Read trace time(s): "} << OutputFile_5D.timer.elapsed_s()\par
00086              << {\cf22 "\\n"};\par
00087         {\cf19 break};\par
00088       {\cf19 case} {\cf23 't'}:\par
00089         {\cf20 // Don't need argument}\par
00090         OutputFile_5D.timer.timeReset();\par
00091         {\cf19 if} (InputFile5D_test.inputRule5D_test(rule5V,\par
00092                                               {\cf22 "./test/inputRule5D_test.txt"})) \{\par
00093           cout << {\cf22 "Input Rule test ERROR!!"}\par
00094                << {\cf22 "\\n"};\par
00095           {\cf19 return} -1;\par
00096         \}\par
00097         cout << {\cf22 "Input rule test time(ns): "} << OutputFile_5D.timer.elapsed_ns()\par
00098              << {\cf22 "\\n"};\par
00099         cout << {\cf22 "Input rule test time(s): "} << OutputFile_5D.timer.elapsed_s()\par
00100              << {\cf22 "\\n"};\par
00101 \par
00102         OutputFile_5D.timer.timeReset();\par
00103         {\cf19 if} (InputFile5D_test.inputPacket5D_test(\par
00104                 packet5V, {\cf22 "./test/inputPacket5D_test.txt"})) \{\par
00105           cout << {\cf22 "Input Packet_5D test ERROR!!"}\par
00106                << {\cf22 "\\n"};\par
00107           {\cf19 return} -1;\par
00108         \}\par
00109         cout << {\cf22 "Input Packet_5D test time(ns): "}\par
00110              << OutputFile_5D.timer.elapsed_ns() << {\cf22 "\\n"};\par
00111         cout << {\cf22 "Input Packet_5D test time(s): "}\par
00112              << OutputFile_5D.timer.elapsed_s() << {\cf22 "\\n"};\par
00113         {\cf19 break};\par
00114       {\cf19 case} {\cf23 'm'}:\par
00115         {\cf20 // Don't need argument}\par
00116         OutputFile_5D.timer.timeReset();\par
00117         InputFile_5D.rule_5D_ip_merge(rule5V);\par
00118         InputFile_5D.packet_5D_ip_merge(packet5V);\par
00119         cout << {\cf22 "Merge ip time(ns): "} << OutputFile_5D.timer.elapsed_ns()\par
00120              << {\cf22 "\\n"};\par
00121         cout << {\cf22 "Merge ip time(s): "} << OutputFile_5D.timer.elapsed_s() << {\cf22 "\\n"};\par
00122         {\cf19 break};\par
00123       {\cf19 case} {\cf23 'n'}:\par
00124         {\cf20 // Don't need argument}\par
00125         OutputFile_5D.timer.timeReset();\par
00126         {\cf19 if} (InputFile5D_test.inputRule5D_merge_test(\par
00127                 rule5V, {\cf22 "./test/inputRule5D_merge_test.txt"})) \{\par
00128           cout << {\cf22 "Input Rule merge test ERROR!!"}\par
00129                << {\cf22 "\\n"};\par
00130           {\cf19 return} -1;\par
00131         \}\par
00132         cout << {\cf22 "Input rule merge test time(ns): "}\par
00133              << OutputFile_5D.timer.elapsed_ns() << {\cf22 "\\n"};\par
00134         cout << {\cf22 "Input rule merge test time(s): "}\par
00135              << OutputFile_5D.timer.elapsed_s() << {\cf22 "\\n"};\par
00136 \par
00137         OutputFile_5D.timer.timeReset();\par
00138         {\cf19 if} (InputFile5D_test.inputPacket5D_merge_test(\par
00139                 packet5V, {\cf22 "./test/inputPacket5D_merge_test.txt"})) \{\par
00140           cout << {\cf22 "Input Packet_5D merge test ERROR!!"}\par
00141                << {\cf22 "\\n"};\par
00142           {\cf19 return} -1;\par
00143         \}\par
00144         cout << {\cf22 "Input Packet_5D merge test time(ns): "}\par
00145              << OutputFile_5D.timer.elapsed_ns() << {\cf22 "\\n"};\par
00146         cout << {\cf22 "Input Packet_5D merge test time(s): "}\par
00147              << OutputFile_5D.timer.elapsed_s() << {\cf22 "\\n"};\par
00148         {\cf19 break};\par
00149       {\cf19 case} {\cf23 'f'}: \{\par
00150         vector<int> tmp_in_field;\par
00151         {\cf18 size_t} i = 0;\par
00152         {\cf19 while} (optarg[i] != {\cf23 '\\0'}) \{\par
00153           {\cf19 if} (optarg[i] != {\cf23 ','}) \{\par
00154             {\cf18 char} c = optarg[i];\par
00155             tmp_in_field.emplace_back(atoi(&c));\par
00156           \}\par
00157           ++i;\par
00158         \}\par
00159         cout << {\cf22 "Set pTree field: "};\par
00160         {\cf19 for} (i = 0; i < tmp_in_field.size() - 1; ++i) \{\par
00161           cout << tmp_in_field[i] << {\cf22 " "};\par
00162           set_field.emplace_back(tmp_in_field[i]);\par
00163         \}\par
00164         cout << {\cf22 "\\nSet aTree port field: "} << tmp_in_field[i] << {\cf22 "\\n"};\par
00165         set_port = tmp_in_field[i];\par
00166         {\cf19 break};\par
00167       \}\par
00168       {\cf19 case} {\cf23 'l'}:\par
00169         enable_log = {\cf17 true};\par
00170         log_level = atoi(optarg);\par
00171         {\cf19 if} (log_level < 1 || log_level > 3) \{\par
00172           fprintf(stderr, {\cf22 "error-unknown log level %d.\\n"}, log_level);\par
00173           {\cf19 return} -1;\par
00174         \}\par
00175         cout << {\cf22 "Enable log:    level "} << log_level << {\cf22 "\\n"};\par
00176         {\cf19 break};\par
00177       {\cf19 case} {\cf23 'u'}:\par
00178         enable_update = {\cf17 true};\par
00179         cout << {\cf22 "Enable update\\n"};\par
00180         {\cf19 break};\par
00181       {\cf19 case} {\cf23 'h'}:\par
00182         cout << {\cf22 "\\n************************************************************"}\par
00183                 {\cf22 "**************************************************************"}\par
00184                 {\cf22 "**********************************\\n"};\par
00185         cout << {\cf22 "* -r(--ruleset): Input the rule set file. This argument must "}\par
00186                 {\cf22 "be specified. (Example: [-r acl1])                            "}\par
00187                 {\cf22 "                                *\\n"};\par
00188         cout << {\cf22 "* -p(--Packet_5D):  Input the Packet_5D set file. If not set, "}\par
00189                 {\cf22 "the "}\par
00190                 {\cf22 "program will generate randomly. (Example: [-p acl1_trace])    "}\par
00191                 {\cf22 "                                 *\\n"};\par
00192         cout << {\cf22 "* -f(--fields):  Set the pTree and aTree used fields, using "}\par
00193                 {\cf22 "\\',\\' to separation. The last on is the port setting, 0 is "}\par
00194                 {\cf22 "source port, 1 is destination port.   *\\n"};\par
00195         cout << {\cf22 "*                Using 0-3 to express source ip 1-4 byte and "}\par
00196                 {\cf22 "4-7 to express destination ip 1-4 byte. (Example: [-f "}\par
00197                 {\cf22 "4,0,1,1])                               *\\n"};\par
00198         cout << {\cf22 "* -l(--log):     Enable the log. Have three level 1-3. "}\par
00199                 {\cf22 "(Example: [-l 3])                                             "}\par
00200                 {\cf22 "                                      *\\n"};\par
00201         cout << {\cf22 "* -u(--update):  Enable update. (Example: [-u])               "}\par
00202                 {\cf22 "                                                              "}\par
00203                 {\cf22 "                               *\\n"};\par
00204         cout << {\cf22 "* -h(--help):    Print the usage guideline.                   "}\par
00205                 {\cf22 "                                                              "}\par
00206                 {\cf22 "                               *\\n"};\par
00207         cout << {\cf22 "**************************************************************"}\par
00208                 {\cf22 "**************************************************************"}\par
00209                 {\cf22 "********************************\\n\\n"};\par
00210         {\cf19 break};\par
00211       {\cf19 case} {\cf23 '?'}:\par
00212         {\cf20 // Invalid option or missing argument}\par
00213         cerr << {\cf22 "Usage: "} << argv[0] << {\cf22 " -h   to get help"}\par
00214              << {\cf22 "\\n"};\par
00215 \par
00216         {\cf19 return} 1;\par
00217       {\cf19 default}:\par
00218         {\cf19 break};\par
00219     \}\par
00220   \}\par
00221   cout << {\cf22 "---START---"}\par
00222        << {\cf22 "\\n"};\par
00223   {\cf19 if} (packets.size() == 0) OutputFile_5D.gen_trace(packets, rules, 10000);\par
00224   setmaskHash();\par
00225 \par
00226 {\cf20   /***********************************************************************************************************************/}\par
00227   {\cf20 // search config}\par
00228 {\cf20   /***********************************************************************************************************************/}\par
00229   {\cf19 if} (set_field.size() == 0) \{\par
00230     cout << {\cf22 "\\nSearch config...\\n"};\par
00231     {\cf18 int} search_leavel = 1000;\par
00232     vector<Packet_5D> tmp_packets;\par
00233     OutputFile_5D.gen_trace(tmp_packets, rules, search_leavel);\par
00234     vector<vector<uint8_t>> fields;\par
00235     vector<uint8_t> tmp_fields;\par
00236     tmp_fields.resize(3);\par
00237     FILE* fp_l3 = fopen({\cf22 "./L3.txt"}, {\cf22 "r"});\par
00238     {\cf19 if} (fp_l3 == NULL) \{\par
00239       fprintf(stderr, {\cf22 "error - can not open L3.txt\\n"});\par
00240       {\cf19 return} 0;\par
00241     \}\par
00242     {\cf19 while} (fscanf(fp_l3, {\cf22 "%hhu %hhu %hhu \\n"}, &tmp_fields[0], &tmp_fields[1],\par
00243                   &tmp_fields[2]) != EOF) \{\par
00244       fields.emplace_back(tmp_fields);\par
00245     \}\par
00246     fclose(fp_l3);\par
00247     tmp_fields.resize(4);\par
00248     FILE* fp_l4 = fopen({\cf22 "./L4.txt"}, {\cf22 "r"});\par
00249     {\cf19 if} (fp_l4 == NULL) \{\par
00250       fprintf(stderr, {\cf22 "error - can not open L4.txt\\n"});\par
00251       {\cf19 return} 0;\par
00252     \}\par
00253     {\cf19 while} (fscanf(fp_l4, {\cf22 "%hhu %hhu %hhu %hhu \\n"}, &tmp_fields[0],\par
00254                   &tmp_fields[1], &tmp_fields[2], &tmp_fields[3]) != EOF) \{\par
00255       fields.emplace_back(tmp_fields);\par
00256     \}\par
00257     fclose(fp_l4);\par
00258     cout << {\cf22 " fields.size: "} << fields.size() << {\cf22 "\\n"};\par
00259     {\cf18 double} min_time = 100e9;\par
00260     {\cf18 double} cur_time = 0;\par
00261     {\cf18 double} best_time = 0;\par
00262     {\cf18 int} best_config1, best_config2 = 1;\par
00263     {\cf17 struct }timespec st1, st2;\par
00264     clock_gettime(CLOCK_REALTIME, &st1);\par
00265     {\cf19 for} ({\cf18 int} i = 0; i < fields.size(); ++i) \{\par
00266       PTtree tree(fields[i], 1);\par
00267       {\cf19 for} ({\cf17 auto}&& r : rules) \{\par
00268         tree.insert(r);\par
00269       \}\par
00270       clock_gettime(CLOCK_REALTIME, &t1);\par
00271       {\cf19 for} ({\cf18 int} j = 0; j < search_leavel; ++j) \{\par
00272         tree.search(tmp_packets[j]);\par
00273       \}\par
00274       clock_gettime(CLOCK_REALTIME, &t2);\par
00275       cur_time = get_nano_time(&t1, &t2);\par
00276 \par
00277       {\cf19 if} (cur_time < min_time) \{\par
00278         min_time = cur_time;\par
00279         best_config1 = i;\par
00280         best_time = cur_time;\par
00281       \}\par
00282     \}\par
00283     \{\par
00284       PTtree tree(fields[best_config1], 0);\par
00285       {\cf19 for} ({\cf17 auto}&& r : rules) \{\par
00286         tree.insert(r);\par
00287       \}\par
00288       clock_gettime(CLOCK_REALTIME, &t1);\par
00289       {\cf19 for} ({\cf18 int} i = 0; i < search_leavel; ++i) \{\par
00290         tree.search(tmp_packets[i]);\par
00291       \}\par
00292       clock_gettime(CLOCK_REALTIME, &t2);\par
00293       cur_time = get_nano_time(&t1, &t2);\par
00294 \par
00295       {\cf19 if} (cur_time < min_time) \{\par
00296         min_time = cur_time;\par
00297         best_config2 = 0;\par
00298         best_time = cur_time;\par
00299       \}\par
00300     \}\par
00301     clock_gettime(CLOCK_REALTIME, &st2);\par
00302     cout << {\cf22 "|- Search config time:    "} << get_milli_time(&st1, &st2) / 1000.0\par
00303          << {\cf22 "s\\n"};\par
00304     cout << {\cf22 "|- Best config:           "};\par
00305     {\cf19 for} ({\cf18 unsigned} {\cf18 int} _f : fields[best_config1]) \{\par
00306       cout << ipFieldName[_f] << {\cf22 ","};\par
00307       set_field.emplace_back(_f);\par
00308     \}\par
00309     {\cf19 if} (best_config2 == 0)\par
00310       cout << {\cf22 "Sport"};\par
00311     {\cf19 else}\par
00312       cout << {\cf22 "Dport"};\par
00313     cout << {\cf22 "\\n|- Minimum lookup time:   "} << best_time / 1000000.0 << {\cf22 "um\\n"};\par
00314     set_port = best_config2;\par
00315   \}\par
00316 \par
00317   PTtree tree(set_field, set_port);\par
00318 \par
00319 {\cf20   /***********************************************************************************************************************/}\par
00320   {\cf20 // insert}\par
00321 {\cf20   /***********************************************************************************************************************/}\par
00322   cout << {\cf22 "\\nStart build...\\n|- Using fields:     "};\par
00323   {\cf19 for} ({\cf18 unsigned} {\cf18 int} x : set_field) cout << x << {\cf22 ","};\par
00324   cout << set_port << {\cf22 "\\n"};\par
00325   clock_gettime(CLOCK_REALTIME, &t1);\par
00326   {\cf19 for} ({\cf17 auto}&& r : rules) \{\par
00327     tree.insert(r);\par
00328   \}\par
00329   clock_gettime(CLOCK_REALTIME, &t2);\par
00330   {\cf18 double} build_time = get_milli_time(&t1, &t2);\par
00331   cout << {\cf22 "|- Construct time:   "} << build_time << {\cf22 "ms\\n"};\par
00332   cout << {\cf22 "tree.totalNodes: "} << tree.totalNodes << {\cf22 "\\n"};\par
00333 \par
00334   cout << {\cf22 "|- Memory footprint: "} << (double)tree.mem() / 1024.0 / 1024.0\par
00335        << {\cf22 "MB\\n"};\par
00336 \par
00337 {\cf20   /***********************************************************************************************************************/}\par
00338   {\cf20 // warm up}\par
00339 {\cf20   /***********************************************************************************************************************/}\par
00340   {\cf19 for} ({\cf18 int} i = 0; i < 10; ++i) \{\par
00341     {\cf19 for} ({\cf18 int} j = 0; j < 1000; ++j) \{\par
00342       tree.search(packets[j]);\par
00343     \}\par
00344   \}\par
00345 \par
00346 {\cf20   /***********************************************************************************************************************/}\par
00347   {\cf20 // Search}\par
00348 {\cf20   /***********************************************************************************************************************/}\par
00349   cout << {\cf22 "\\nstart search...\\n"};\par
00350   {\cf18 int} res = 0;\par
00351   FILE* res_fp = NULL;\par
00352   res_fp = fopen({\cf22 "../info/results.txt"}, {\cf22 "w"});\par
00353   {\cf18 double} search_time = 0;\par
00354   {\cf19 for} ({\cf18 int} i = 0; i < packets.size(); ++i) \{\par
00355     clock_gettime(CLOCK_REALTIME, &t1);\par
00356     res = tree.search(packets[i]);\par
00357     clock_gettime(CLOCK_REALTIME, &t2);\par
00358     {\cf18 double} _time = get_nano_time(&t1, &t2);\par
00359     search_time += _time;\par
00360     {\cf20 // int true_result = simple_search(rules, packets[i]);}\par
00361     {\cf20 // if (res != true_result) \{}\par
00362     {\cf20 //  fprintf(stderr, "Packet_5D %d search result is uncorrect! True is %d,}\par
00363     {\cf20 // but}\par
00364     {\cf20 // result %d.\\n", i, true_result, res);}\par
00365     {\cf20 //  //return -1;}\par
00366     {\cf20 // \}}\par
00367     fprintf(res_fp, {\cf22 "Packet_5D %d \\t Result %d \\t Time(um) %f\\n"}, i, res,\par
00368             _time / 1000.0);\par
00369   \}\par
00370   fclose(res_fp);\par
00371   cout << {\cf22 "|- Average search time: "} << search_time / packets.size() / 1000.0\par
00372        << {\cf22 "um\\n"};\par
00373 \par
00374 {\cf20   /***********************************************************************************************************************/}\par
00375   {\cf20 // Print Log}\par
00376 {\cf20   /***********************************************************************************************************************/}\par
00377   {\cf19 if} (enable_log) \{\par
00378     cout << {\cf22 "\\nPrint Log...\\n"};\par
00379     {\cf20 // level 1: print node information}\par
00380     tree.print_node_info(log_level, rules.size());\par
00381     {\cf20 // level 2: print search information}\par
00382     {\cf19 if} (log_level > 1) \{\par
00383       FILE* log_fp = NULL;\par
00384       {\cf19 if} (log_level > 2) \{\par
00385         log_fp = fopen({\cf22 "../info/search_info.txt"}, {\cf22 "w"});\par
00386         fprintf(log_fp,\par
00387                 {\cf22 "Search Log [PACKET_ID ACC_INNERNODE ACC_LEAFNODE ACC_TABLE "}\par
00388                 {\cf22 "ACC_RULE ACC_IPNODE ACC_PORTNODE]\\n\\n"});\par
00389       \}\par
00390       {\cf18 double} acc_inner, acc_leaf, acc_table, acc_rule;\par
00391       acc_inner = acc_leaf = acc_table = acc_rule = 0;\par
00392       {\cf19 for} ({\cf18 int} i = 0; i < packets.size(); ++i) \{\par
00393         ACL_LOG log;\par
00394         tree.search_with_log(packets[i], log);\par
00395         acc_inner += log.innerNodes;\par
00396         acc_leaf += log.leafNodes;\par
00397         acc_table += log.tables;\par
00398         acc_rule += log.rules;\par
00399         {\cf19 if} (log_level > 2)\par
00400           fprintf(log_fp, {\cf22 "%d\\t%hhu\\t%hhu\\t%hhu\\t%hhu\\t%llu\\t%llu\\n"}, i,\par
00401                   log.innerNodes, log.leafNodes, log.tables, log.rules,\par
00402                   log.ipNodeList.size(), log.portNodeList.size());\par
00403       \}\par
00404       cout << {\cf22 "|- Access innerNode avg num: "} << acc_inner / packets.size()\par
00405            << {\cf22 "\\n"};\par
00406       cout << {\cf22 "|- Access leafNode avg num:  "} << acc_leaf / packets.size()\par
00407            << {\cf22 "\\n"};\par
00408       cout << {\cf22 "|- Access table avg num:     "} << acc_table / packets.size()\par
00409            << {\cf22 "\\n"};\par
00410       cout << {\cf22 "|- Access rule avg num:      "} << acc_rule / packets.size()\par
00411            << {\cf22 "\\n"};\par
00412       {\cf19 if} (log_level > 2) \{\par
00413         cout << {\cf22 "|- Write search infomation to search_info.txt...\\n"};\par
00414         fclose(log_fp);\par
00415       \}\par
00416     \}\par
00417   \}\par
00418 \par
00419 {\cf20   /***********************************************************************************************************************/}\par
00420   {\cf20 // update}\par
00421 {\cf20   /***********************************************************************************************************************/}\par
00422   {\cf19 if} (enable_update) \{\par
00423     {\cf18 int} update_num = 5000;\par
00424     cout << {\cf22 "\\nStart update...\\n"};\par
00425     {\cf18 bool} _u = tree.update(rules, update_num, t1, t2);\par
00426     {\cf19 if} (_u) \{\par
00427       cout << {\cf22 "|- Average update time: "}\par
00428            << get_nano_time(&t1, &t2) / update_num / 2000.0 << {\cf22 "um\\n"};\par
00429     \}\par
00430   \}\par
00431 \par
00432   cout << {\cf22 "\\nProgram complete.\\n"};\par
00433   {\cf19 return} 0;\par
00434 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
README.md File Reference\par \pard\plain 
{\tc\tcl2 \v README.md}
{\xe \v README.md}
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}
